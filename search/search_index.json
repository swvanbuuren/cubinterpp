{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to cubinterpp's documentation!","text":"<p>Cubinterpp is a C++ header library for cubic and linear interpolation with Python support. Read the introduction for an elaborate explanation as well as data requirements.</p> <p>This documentation features usage instructions to build and test cubinterpp. This also shows how to plot the exemplary plots of 1D and 2D interpolation by leveraging mlpyqtgraph. Here, you'll also find instructions how to use the library in your own C++ program.</p> <p>A theoretical foundation on the interpolation algorithms is found in mathematical background.</p> <p>The code reference section features the actual C++ code documentation.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>This C++ header library features tools for piecewise linear and cubic interpolation.</p> <p>For cubic piecewise interpolation, the library features three types:</p> <ul> <li>Monotone cubic interpolation</li> <li>Akima spline interpolation </li> <li>Natural cubic spline interpolation</li> </ul> <p>Linear interpolation is supported for <code>N</code>-dimensional data, whereas cubic interpolation currently only supports <code>1</code>- and <code>2</code>-dimensional data. Cubic piecewise interpolation for <code>N</code>-dimensional data is planned.</p> <p>All classes are templatized and support the STL's vector types.</p> <p>The accompanying python script <code>main.py</code> in cubinterpp  compares the interpolation types.</p> <p>The following figure features a comparison of 1D interpolation types that are supported by cubinterpp.</p> <p></p>"},{"location":"requirements/","title":"Requirements","text":"<p>The following requirements need to be met to build and properly use cubinterpp.</p>"},{"location":"requirements/#installation-prerequisites","title":"Installation prerequisites","text":"<ul> <li>C++ compiler, capable of compiling C++20 or later, e.g.   gcc</li> <li>cmake: to use the provided cmake configuration</li> <li>pybind11: to compile the library header   into a python module</li> <li>mlpyqtgraph: to plot the   example's results</li> </ul>"},{"location":"requirements/#data-requirements","title":"Data requirements","text":"<p><code>cubinterpp</code> is designed to only handle rectangular grid data with strictly ascending coordinates. To this end, coordinate data is only required in one dimensional form for each coordinate direction. Only the actual data itself needs to be supplied in the actual dimensions. The user is responsible to assure that the supplied data size of each dimension fits to the coordinate data.</p>"},{"location":"usage/","title":"Usage instructions","text":"<p>The following instructions show how to build and test the cubinterpp header library in a python environment.</p>"},{"location":"usage/#prerequisites","title":"Prerequisites","text":"<p>Refer to installation prerequisites.</p>"},{"location":"usage/#single-header-library","title":"Single header library","text":"<p>The easiest way to use cubinterpp in your project is to use the single header library.</p> <p>Starting with release v0.8.0 each release comes with the single header library as asset. Alternatively, you can build the single header library yourself with (assuming <code>python3</code> is already installed):</p> <pre><code>python3 create_single_header.py \\\n          --entry include/cubinterpp.hpp \\\n          --output ./build/cubinterpp_header.hpp \\\n          --license LICENSE\n</code></pre> <p>Since mdspan is not yet supported in the standard library you also need to get its corresponding single header library from the mdspan repository.</p> <p>After putting both <code>cubinterpp_header.hpp</code> and <code>mdspan.hpp</code> into you <code>include</code> directory, you can use cubinterpp in your project by just adding it to the includes in your codebase:</p> <pre><code>#include \"cubinterpp_header.hpp\"\n</code></pre>"},{"location":"usage/#build-from-source","title":"Build from source","text":"<p>To build the header library for usage in Python, it's recommended to use cmake. An appropriate cmake configuration is provided in the main <code>CMakeLists.txt</code>. Prior to compilation, the required external libraries are downloaded automatically using the cmake FetchContent module. Prior to building, make sure <code>cmake</code> is installed and configured with a C++ compiler like e.g. gcc. In order to create the python module, the development python library is also required.</p> <p>In order to do so on a Debian based system, install <code>cmake</code>, <code>gcc</code>, <code>g++</code> and <code>python3.11-dev</code> (change the python version depending on your configuration):</p> <pre><code>sudo apt install cmake gcc g++ python3.11-dev\n</code></pre> <p>Set the appropriate environment variables (it's recommended to add these lines to e.g. your <code>.bashrc</code>):</p> <pre><code>export CC=/usr/bin/gcc\nexport CXX=/usr/bin/g++\n</code></pre> <p>Then create the build directory, configure and build using:</p> <pre><code>mkdir build\ncmake ..\nmake\n</code></pre> <p>This should build and automatically copy the library file <code>cubic_spline.*.so</code> into the <code>cubinterpp</code> directory.</p>"},{"location":"usage/#testing","title":"Testing","text":"<p>This library comes with severals tests. To run all tests, first build and then run (while remaining in the <code>build</code> directory):</p> <pre><code>ctest -V\n</code></pre>"},{"location":"usage/#interpolating-and-plotting-the-results","title":"Interpolating and plotting the results","text":"<p>A python program is provided to compare the three interpolation types. Data preparation and visualization is done in python with mlpyqtgraph.</p> <p>In order to run the python program, it's recommended to install uv and issue:</p> <pre><code>uv run cubinterpp \n</code></pre> <p>This should install all required python dependencies automatically and run the python program that does the interpolation and plotting, resulting in the comparison plot shown at the top of this document.</p>"},{"location":"usage/#higher-interpolation-dimensions","title":"Higher interpolation dimensions","text":"<p>By default, the library offers linear interpolation classes up to three dimensions with <code>std::vector</code> input types. If you'd like to implement higher dimensions, it's recommended to inherit from the <code>N-dimensional</code> interpolation class for a given dimension. For example, for three dimensional linear interpolation this could look like:</p> <pre><code>#include \"linear_interp.hpp\"\n\ntemplate &lt;typename T&gt;\nclass LinearInterp3D : public LinearInterpND&lt;T, 3&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    using Vector3 = cip::VectorN&lt;T, 3&gt;;\npublic:\n    explicit LinearInterp3D(const Vector &amp;x, const Vector &amp;y, const Vector &amp;z, const Vector3 &amp;f)\n    : LinearInterpND&lt;T, 3&gt;(f, x, y, z)\n    {}\n\n    ~LinearInterp3D() { }\n};\n</code></pre> <p>Note the counter-intuitive order of the constructor argument in <code>LinearInterpND</code>, due to the requirement that a parameter pack always needs to come last. This can be corrected in the inheriting classes constructor. Here, it's also possible to use different input types, which might differ per application.</p>"},{"location":"reference/","title":"Code reference","text":"<p>This section contains generated code documentation for <code>cubinterpp</code>.</p>"},{"location":"theory/","title":"Mathematical background","text":"<p>The mathematical foundation of the interpolation algorithms used in Cubinterpp is based on the mathematical formulations outlined by Lalescu, 2009<sup>1</sup>. Lalescu treats Hermite splines as well as grid splines. Cubinterpp only uses the former type of splines.</p> <p>First, the general definition of <code>1</code>-Dimensional (<code>1D</code>) splines and the generalization to <code>N</code>-Dimensional (<code>ND</code>) Hermite splines for \\(n^\\textrm{th}\\) order splines shall be introduced here.</p> <p>Spline definitions are only given for a specific interval (a.k.a. cell). E.g. for the <code>1</code>-Dimensional case this would be \\(x \\in [x_0, x_0 + h]\\) for which the values of \\(f(x)\\) are provided on the interval edges, i.e. \\(x_0\\) and \\(x_0 + h\\).  </p> <p>Note</p> <p>The extension to piecewise interpolation with a series neighboring cells is not treated here.</p>"},{"location":"theory/#1-dimension","title":"<code>1</code> dimension","text":"<p>The main goal is to find an approximating interpolation of \\(f(x)\\) on an interval \\(x \\in [x_0, x_0 + h]\\), given values and derivatives of \\(f(x)\\) on the boundaries of that interval. In the following the interval is normalized from \\(x \\in [x_0, x_0 + h]\\) to \\(\\bar x \\in [0, 1]\\). </p> <p>Tip</p> <p>The sections for the linear and cubic interpolation will give the non-normalized formulations.</p> <p>For the <code>1</code>-Dimensional case, the goal is to obtain a polynomial</p> \\[ s^{(n)}(\\bar x) = \\sum_{k=0}^n \\bar a^{(n)}_k \\bar x^k, \\] <p>that approximates \\(f(x)\\) in the interpolation interval. Here, \\(n\\) is the order of the spline, \\(\\bar x\\) the variable coordinate and \\(\\bar a_k\\) are the to-be-determined coefficients.</p> <p>The (derivate) values \\(f^{(l)}(\\bar x)\\), where \\(f^{(l)}(\\bar x) \\equiv \\frac{\\textrm{d}^lf(\\bar x)}{\\textrm{d}\\bar x^l}\\), are assumed to coincide with those of \\(s^{(n)}(\\bar x)\\) on the boundaries of the interval.</p> <p>Given this, according to Lalescu, 2009<sup>1</sup>, \\(s^{(n)}(\\bar x)\\) can be written as follows:</p> \\[ s^{(n)}(\\bar x) = \\sum_{l=0}^{} \\sum_{i=0,1} f^{(l)}(i) \\alpha^{(n,l)}_i (\\bar x), \\] <p>where \\(m \\equiv (n-1)/2\\) and \\(\\alpha^{(n,l)}_i\\) becomes</p> \\[ \\begin{align*} \\alpha^{(n,l)}_0 (x) &amp;= \\frac{x^l}{l!}(1-x)^{m+1} \\sum_{k=0}^{m-l} \\frac{(m+k)!}{m! k!}x^k \\\\ \\alpha^{(n,l)}_1 (x) &amp;= \\frac{(x-1)^l}{l!}x^{m+1} \\sum_{k=0}^{m-l} \\frac{(m+k)!}{m! k!}(1-x)^k \\end{align*} \\] <p>Using this, it's possible to determine the values of \\(a_k\\).</p>"},{"location":"theory/#n-dimensions","title":"<code>N</code> dimensions","text":"<p>For the <code>ND</code> case, the polynomial to describe the interpolation with \\(N\\) variables \\(\\bar x_i\\) for \\(i=1,\\dots,N\\) defined for the interval \\([0, 1]^N\\) reads</p> \\[ s^{(n)}(\\bar x_1,\\bar x_2,\\dots,\\bar x_N) = \\sum_{i_1,\\dots,i_N=0}^n \\bar a_{i_1,\\dots,i_N}\\prod_{k=0}^N\\bar x_{k}^{i_k} \\] <p>The <code>1D</code> spline definition, now depending on the input values of \\(f^{(l_1,\\dots,l_N)}(\\bar x_1,\\dots,\\bar x_N)\\) can be directly be generalized to the following:</p> \\[ s^{(n)}(\\bar x_1,\\bar x_2,\\dots,\\bar x_N) = \\sum_{l_1,\\dots,l_N=0}^m \\sum_{i_1,\\dots,i_N=0,1} f^{(l_1,\\dots,l_N)}(i_1,\\dots,i_N) \\prod_{k=1}^N \\alpha^{(n,l_k)}_{i_k} (\\bar x_k) \\] <p>For multiple dimensions, we're now also dealing with (combined) derivatives in multiple directions. That is, \\(f^{(l_1,\\dots,l_N)}\\), which is defined as:</p> \\[ f^{(l_1,\\dots,l_N)}(\\bar x_1,\\dots,\\bar x_N) = \\left( \\prod_{j=1}^{N} \\left(\\frac{\\partial}{\\partial \\bar x_j}\\right)^{l_j} \\right)f(\\bar x_1,\\dots,\\bar x_N) \\] <p>Using this, it's possible to determine the values of \\(\\bar a_{i_1,\\dots,i_N}\\).</p>"},{"location":"theory/#specific-implementations","title":"Specific implementations","text":"<p>Specific derivations for linear (\\(n=1\\)) and cubic splines (\\(n=3\\)) can be found in the sections linear interpolation and cubic interpolation. These sections will show how to determine the values of \\(a_k\\) and \\(a_{i_1,\\dots,i_N}\\) for the <code>1D</code>, <code>2D</code> and <code>ND</code> cases, and will also present the non-normalized formulations.</p> <ol> <li> <p>Lalescu, C.C., 2009,  Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines. arXiv:0905.3564 \u21a9\u21a9</p> </li> </ol>"},{"location":"theory/cubic/","title":"Cubic interpolation","text":"<p>For cubic interpolation, the polynomial order is raised to \\(n=3\\). Now, for a given interal \\(\\bar x \\in [0, 1]^N\\) we're looking for the values \\(a_{i_1,\\dots,i_N}\\) in the following function</p> \\[ s(\\bar x_1,\\dots,\\bar x_N) = \\sum_{i_1,\\dots,i_N=0}^3 \\bar a_{i_1 \\dots i_N}\\prod_{k=0}^N\\bar x_{k}^{i_k} \\] <p>Expressing \\(s(\\bar x_1,\\dots,\\bar x_N)\\) in terms of \\(f(\\bar x_1,\\dots,\\bar x_N)\\) leads to:</p> \\[ \\begin{equation} s(\\bar x_1,\\dots,\\bar x_N) = \\sum_{i_1,\\dots,i_N=0}^1 \\sum_{j_1,\\dots,j_N=0}^1  f^{(j_1,\\dots,j_N)}(i_1,\\dots,i_N) \\prod_{k=1}^N \\alpha^{(3,j_k)}_{i_k} (\\bar x_k), \\label{eq:s_normalized} \\end{equation} \\] <p>where</p> \\[ \\begin{align*} \\alpha_0^{3,0}(\\bar x_k) &amp;= 1 - 3\\bar x_k^2 + 2 \\bar x_k ^3\\\\ \\alpha_0^{3,1}(\\bar x_k) &amp;= 3\\bar x_k^2 - 2\\bar x_k^3\\\\ \\alpha_1^{3,0}(\\bar x_k) &amp;= \\bar x_k - 2 \\bar x_k^2 + \\bar x_k^3\\\\ \\alpha_1^{3,1}(\\bar x_k) &amp;=-\\bar x_k^2 + \\bar x_k^3 \\end{align*} \\] <p>The reader is reminded that, as stated here, \\(f^{(l)}(\\bar x) \\equiv \\frac{\\textrm{d}^lf(\\bar x)}{\\textrm{d}\\bar x^l}\\). For cubic interpolation only zeroth and first order differentation occurs, which occasionaly might be denoted using \\(f(\\bar x)\\) and \\(f'(\\bar x)\\) respectively. Analogue to linear interpolation, \\(\\eqref{eq:s_normalized}\\) is also rewritten to its non-normalized version:</p> \\[ s(x_1,\\dots,x_N) = \\sum_{i_1,\\dots,i_N=0}^3 a_{i_1 \\dots i_N}\\prod_{k=0}^N x_{k}^{i_k} \\] <p>in which we're looking for expressions for the coefficients \\(a_{i_1 \\dots i_N}\\). By substututing \\(\\bar x_k = (x_k - {}^0x_k)/h_k\\) (where \\(h_k={}^1x_k-{}^0x_k\\)) into \\(\\eqref{eq:s_normalized}\\) we obtain</p> \\[ \\begin{equation} \\begin{split} s(x_1,\\dots,x_N) = \\sum_{i_1,\\dots,i_N=0}^1 \\sum_{j_1,\\dots,j_N=0}^1 &amp; \\left( \\prod_{k=1}^N h_k^{j_k} \\right) f^{(j_1,\\dots,j_N)}({}^{i_1}x_1,\\dots,{}^{i_N}x_N) \\dots \\\\ &amp; \\dots \\prod_{k=1}^N \\alpha^{(3,j_k)}_{i_k} (x_k) \\end{split} \\label{eq:s_non_normalized} \\end{equation} \\] <p>Note the additional term \\(\\prod_{k=1}^N h_k^{j_k}\\), which arises due to substition of \\(\\bar x_k = (x_k - {}^0x_k)/h_k\\) into \\(f^{(l)}(\\bar x_k)\\). In \\(\\eqref{eq:s_non_normalized}\\) \\(\\alpha_{i_k}^{(3,j_k)}\\) can be expressed as:</p> \\[ \\begin{align*} \\alpha_0^{3,0}(x_k) &amp;= \\frac{1}{h_k^3} \\sum^3_{i=0} \\delta^{(0,i)}_k x_k^i\\\\ \\alpha_0^{3,1}(x_k) &amp;= \\frac{1}{h_k^3} \\sum^3_{i=0} \\delta^{(1,i)}_k x_k^i\\\\ \\alpha_1^{3,0}(x_k) &amp;= \\frac{1}{h_k^3} \\sum^3_{i=0} \\delta^{(2,i)}_k x_k^i\\\\ \\alpha_1^{3,1}(x_k) &amp;= \\frac{1}{h_k^3} \\sum^3_{i=0} \\delta^{(3,i)}_k x_k^i \\end{align*} \\] <p>in which the expressions \\(\\delta^{(j,i)}_k\\) read</p> \\(i=0\\) \\(i=1\\) \\(i=2\\) \\(i=3\\) \\(j=0\\) \\({}^1x_k^2({}^1x_k-3{}^0x_k)\\) \\(+6{}^0x_k{}^1x_k\\) \\(-3({}^0x_k+{}^1x_k)\\) \\(+2\\) \\(j=1\\) \\(-{}^0x_k{}^1x_k^2\\) \\({}^1x_k(2{}^0x_k+{}^1x_k)\\) \\(-({}^0x_k+2{}^1x_k)\\) \\(+1\\) \\(j=2\\) \\({}^0x_k^2(3{}^1x_k-{}^0x_k)\\) \\(-6{}^0x_k{}^1x_k\\) \\(+3({}^0x_k+{}^1x_k)\\) \\(-2\\) \\(j=3\\) \\(-{}^1x_k{}^0x_k^2\\) \\({}^0x_k({}^0x_k+2{}^1x_k)\\) \\(-(2{}^0x_k+{}^1x_k)\\) \\(+1\\) <p>Note that expression for \\(\\alpha_i^{3,j}\\) can be written even shorter by introducing a binary number \\(ij\\), i.e. \\(00, 01, 10, 11 = 0, 1, 2, 3\\):</p> \\[ \\begin{equation} \\alpha_i^{3,j}(x_k) = \\frac{1}{h_k^3} \\sum_{l=0}^3 \\delta_k^{(ij,l)}x_k^i \\label{eq:unified_alpha} \\end{equation} \\] <p>The following sections show how to employ \\(\\eqref{eq:s_non_normalized}\\) to obtain expressions for the coefficients \\(a_{i_1 \\dots i_N}\\) for <code>1</code>, <code>2</code> and <code>N</code> dimensions.</p>"},{"location":"theory/cubic/#1-dimension","title":"<code>1</code> dimension","text":"<p>For <code>1</code> dimension the interval definition simplifies to \\(x \\in [x_0, x_1]\\). With this:</p> \\[ \\begin{equation} s(x) = \\sum_{k=0}^3 a_k x^k =  a_0 + a_1 x + a_2 x^2 + a_3 x^3 \\end{equation} \\] <p>in which the coefficients can be written as</p> \\[ \\begin{align*} a_0 &amp;= (f(x_ 0)x_1^2(x_1 - 3 x_0) + f(x_1)x_0^2(3x_1 - x_0) - h x_0 x_1(x_1f'(x_0) +  x_0f'(x_1)))/h^3\\\\ a_1 &amp;= (+6 x_0 x_1 (f_0-f_1) + h ( x_1 (2 x_0 + x_1)f'(x_0) + x_0 (x_0 + 2 x_1)f'(x_1)))/h^3\\\\ a_2 &amp;= (-3 (x_0 + x_1)(f_0-f_1) - h( (x_0 + 2 x_1)f'(x_0) + (2 x_0 + x_1)f'(x_1)))/h^3\\\\ a_3 &amp;= (+2 (f_0-f_1) + h (f'(x_0) + f'(x_1)))/h^3 \\end{align*} \\] <p>where \\(h = x_1 - x_0\\).</p>"},{"location":"theory/cubic/#2-dimensions","title":"<code>2</code> dimensions","text":"<p>For <code>2</code> dimensions the interval definition now reads \\(x \\in [{}^0x, {}^1x]^2\\). With this:</p> \\[ \\begin{align*} s(x_1,x_2) = &amp; \\sum_{k,l=0}^3 a_{kl} x_1^k x_2^l \\end{align*} \\] <p>Now, we're looking for the coefficients \\(a_{kl}\\) for \\(k,l=0,1,2,3\\). Analogue to linear interpolationt this is accomplished by rewriting \\(\\eqref{eq:s_non_normalized}\\) for \\(N=2\\). To simplify the expressions, we shall rewrite \\(f_{ij}^{(k,l)} = f^{(k,l)}({}^{i}x_1{}^{j}x_2)\\). This leads to</p> \\[ \\begin{align*} s(x_1,x_2) = &amp; \\sum_{i_1,i_2=0}^1 \\sum_{j_1,j_2=0}^1  h_1^{j_1}h_2^{j_2} f_{i_1i_2}^{(j_1,j_2)} \\alpha^{(3,j_1)}_{i_1} (x_1) \\alpha^{(3,j_2)}_{i_2} (x_2)\\\\ =&amp; \\frac{1}{h_1^3 h_2^3} \\sum_{i_1,i_2=0}^1 \\sum_{j_1,j_2=0}^1    h_1^{j_1}h_2^{j_2} f_{i_1i_2}^{(j_1,j_2)} \\sum_{k,l=0}^3\\delta_1^{(i_1j_1,k)} \\delta_2^{(i_2j_2,l)} \\\\ =&amp; \\frac{1}{h_1^3 h_2^3} \\sum^3_{k,l=0} \\Bigl( \\\\   &amp; f_{00}^{(0,0)} \\delta^{(0,k)}_1 \\delta^{(0,l)}_2  +     f_{01}^{(0,0)} \\delta^{(0,k)}_1 \\delta^{(1,l)}_2  +     f_{10}^{(0,0)} \\delta^{(1,k)}_1 \\delta^{(0,l)}_2  +     f_{11}^{(0,0)} \\delta^{(1,k)}_1 \\delta^{(1,l)}_2 ~ + \\\\  &amp; h_2\\left(f_{00}^{(0,1)} \\delta^{(0,k)}_1 \\delta^{(2,l)}_2 +              f_{01}^{(0,1)} \\delta^{(0,k)}_1 \\delta^{(3,l)}_2 +             f_{10}^{(0,1)} \\delta^{(1,k)}_1 \\delta^{(2,l)}_2 +             f_{11}^{(0,1)} \\delta^{(1,k)}_1 \\delta^{(3,l)}_2\\right) ~ + \\\\  &amp; h_1\\left(f_{00}^{(1,0)} \\delta^{(2,k)}_1 \\delta^{(0,l)}_2 +              f_{01}^{(1,0)} \\delta^{(2,k)}_1 \\delta^{(1,l)}_2 +              f_{10}^{(1,0)} \\delta^{(3,k)}_1 \\delta^{(0,l)}_2 +              f_{11}^{(1,0)} \\delta^{(3,k)}_1 \\delta^{(1,l)}_2 \\right)~ + \\\\  &amp; h_1h_2\\left(f_{00}^{(1,1)} \\delta^{(2,k)}_1 \\delta^{(2,l)}_2 +                 f_{01}^{(1,1)} \\delta^{(2,k)}_1 \\delta^{(3,l)}_2 +                f_{10}^{(1,1)} \\delta^{(3,k)}_1 \\delta^{(2,l)}_2 +                f_{11}^{(1,1)} \\delta^{(3,k)}_1 \\delta^{(3,l)}_2 \\right)\\\\ &amp; \\Bigr)x_1^k x_2^l \\end{align*} \\] <p>From this it becomes clear that</p> \\[ \\begin{align*} a_{kl} = &amp; \\frac{1}{h_1^3 h_2^3}   \\Biggl( f_{00}^{(0,0)} \\delta^{(0,k)}_1 \\delta^{(0,l)}_2  +     f_{01}^{(0,0)} \\delta^{(0,k)}_1 \\delta^{(1,l)}_2  +     f_{10}^{(0,0)} \\delta^{(1,k)}_1 \\delta^{(0,l)}_2  +     f_{11}^{(0,0)} \\delta^{(1,k)}_1 \\delta^{(1,l)}_2 ~ + \\\\  &amp; h_2\\left(f_{00}^{(0,1)} \\delta^{(0,k)}_1 \\delta^{(2,l)}_2 +              f_{01}^{(0,1)} \\delta^{(0,k)}_1 \\delta^{(3,l)}_2 +             f_{10}^{(0,1)} \\delta^{(1,k)}_1 \\delta^{(2,l)}_2 +             f_{11}^{(0,1)} \\delta^{(1,k)}_1 \\delta^{(3,l)}_2\\right) ~ + \\\\  &amp; h_1\\left(f_{00}^{(1,0)} \\delta^{(2,k)}_1 \\delta^{(0,l)}_2 +              f_{01}^{(1,0)} \\delta^{(2,k)}_1 \\delta^{(1,l)}_2 +              f_{10}^{(1,0)} \\delta^{(3,k)}_1 \\delta^{(0,l)}_2 +              f_{11}^{(1,0)} \\delta^{(3,k)}_1 \\delta^{(1,l)}_2 \\right)~ + \\\\  &amp; h_1h_2\\left(f_{00}^{(1,1)} \\delta^{(2,k)}_1 \\delta^{(2,l)}_2 +                 f_{01}^{(1,1)} \\delta^{(2,k)}_1 \\delta^{(3,l)}_2 +                f_{10}^{(1,1)} \\delta^{(3,k)}_1 \\delta^{(2,l)}_2 +                f_{11}^{(1,1)} \\delta^{(3,k)}_1 \\delta^{(3,l)}_2 \\right)\\Biggr)\\\\ \\end{align*} \\]"},{"location":"theory/cubic/#n-dimensions","title":"<code>N</code> dimensions","text":"<p>For <code>N</code> dimensions, replacing the \\(\\alpha\\)-terms in \\(\\eqref{eq:s_non_normalized}\\) with the simplified \\(\\alpha\\)-terms from \\(\\eqref{eq:unified_alpha}\\):</p> \\[ \\begin{equation} \\begin{split} s(x_1,\\dots,x_N) = \\sum_{i_1,\\dots,i_N=0}^1 \\sum_{j_1,\\dots,j_N=0}^1 &amp; \\left( \\prod_{k=1}^N h_k^{j_k} \\right) f^{(j_1,\\dots,j_N)}({}^{i_1}x_1,\\dots,{}^{i_N}x_N) \\dots \\\\ &amp; \\dots \\prod_{k=1}^N \\frac{1}{h_k^3} \\sum_{l=0}^3 \\delta_k^{(i_kj_k,l)}x_k^i \\end{split} \\end{equation} \\] <p>This can be reordered to</p> \\[ s(x_1,\\dots,x_N) = \\sum_{\\mathbf{m}\\in\\{0,1,2,3\\}^N} A_{\\textbf{m}}\\prod_{k=1}^N x_k^{m_k}, \\] <p>where</p> \\[ A_{\\textbf{m}} =\\sum_{i_1,\\dots,i_N=0}^1 \\sum_{j_1,\\dots,j_N=0}^1 f^{(j_1,\\dots,j_N)}\\Bigl({}^{i_1}x_1,\\dots,{}^{i_N}x_N\\Bigr) \\prod_{k=1}^N \\frac{h_k^{\\,j_k}}{h_k^3}\\,\\delta_k^{(i_kj_k,m_k)} \\] <p>In here, \\(\\textbf{m}\\) is defined as</p> \\[ \\mathbf{m}=(m_1,\\dots,m_N) \\quad \\text{with} \\quad m_k\\in\\{0,1,2,3\\}. \\] <p>\\(A_\\textbf{m}\\) can be rewritten to the original coefficients: \\(A_\\textbf{m} = A_{(m_1,\\dots,m_N)} = a_{m_1 \\dots m_N}\\).</p>"},{"location":"theory/linear/","title":"Linear interpolation","text":"<p>For linear interpolation, the order of the polynomial \\(n = 1\\). Thus, for a given interval \\(\\bar x \\in [0, 1]^N\\) now we're looking for the values \\(a_{i_1,\\dots,i_N}\\) in the following function</p> \\[ s(\\bar x_1,\\dots,\\bar x_N) = \\sum_{i_1,\\dots,i_N=0}^1 \\bar a_{i_1 \\dots i_N}\\prod_{k=0}^N\\bar x_{k}^{i_k} \\] <p>As stated here, \\(s(\\bar x_1,\\dots,\\bar x_N)\\) can also be expressed in terms of \\(f(\\bar x_1, \\dots, \\bar x_n)\\). For linear interpolation (\\(n=1\\)), this boils down to:</p> \\[ \\begin{equation} s(\\bar x_1,\\dots,\\bar x_N) = \\sum_{i_1,\\dots,i_N=0,1} f(i_1,\\dots,i_N) \\prod_{k=1}^N \\alpha^{(1,0)}_{i_k} (\\bar x_k), \\label{eq:s_normalized} \\end{equation} \\] <p>where</p> \\[ \\begin{align} \\alpha_0^{(1,0)}(\\bar x_k) &amp;= 1 - \\bar x_k \\label{eq:alpha0_normalized} \\\\ \\alpha_1^{(1,0)}(\\bar x_k) &amp;= \\bar x_k \\label{eq:alpha1_normalized} \\end{align} \\] <p>To avoid unnecessary computations during evaluation, equation \\(\\eqref{eq:s_normalized}\\) as well as \\(\\eqref{eq:alpha0_normalized}\\) and \\(\\eqref{eq:alpha1_normalized}\\) have to be rewritten to its non-normalized version. The interval is now defined by \\(x \\in [{}^0x, {}^1x]^N\\). We're now looking for \\(s(x_1,\\dots,x_N)\\):</p> \\[ s(x_1,\\dots,x_N) = \\sum_{i_1,\\dots,i_N=0}^1 a_{i_1 \\dots i_N}\\prod_{k=0}^N x_{k}^{i_k}, \\] <p>in which the coefficients \\(a_{i_1 \\dots i_N}\\) need to be determined. The transformation is achieved by substituting \\(\\bar x = (x - {}^0x)/h\\) (where \\(h={}^1x-{}^0x\\)) into \\(\\eqref{eq:s_normalized}\\). This leads to</p> \\[ \\begin{equation} s(x_1,\\dots,x_N) = \\sum_{i_1,\\dots,i_N=0,1} f({}^{i_1}x_1,\\dots,{}^{i_N}x_N) \\prod_{k=1}^N \\alpha^{(1,0)}_{i_k} (x_k), \\label{eq:s_non_normalized} \\end{equation} \\] <p>where</p> \\[ \\begin{align} \\alpha_0^{(1,0)}(x_k) &amp;= \\frac{1}{h_k} \\sum^1_{i=0} \\gamma^{(0,i)}_k x_k^i,~~~\\textrm{where}~~~ \\gamma^{(0,0)}_k = +{}^{1}x_k,~~~\\gamma^{(0,1)}_k = - 1 \\label{eq:alpha0_non_normalized}\\\\ \\alpha_1^{(1,0)}(x_k) &amp;= \\frac{1}{h_k} \\sum^1_{i=0} \\gamma^{(1,i)}_k x_k^i,~~~\\textrm{where}~~~ \\gamma^{(1,0)}_k = -{}^{0}x_k,~~~\\gamma^{(1,1)}_k = +1 \\label{eq:alpha1_non_normalized} \\end{align} \\] <p>The following sections show how to employ \\(\\eqref{eq:s_non_normalized}\\) to obtain expressions for the coefficients \\(a_{i_1 \\dots i_N}\\) for <code>1</code>, <code>2</code> and <code>N</code> dimensions.</p>"},{"location":"theory/linear/#1-dimension","title":"<code>1</code> dimension","text":"<p>For <code>1</code> dimension the interval definition simplifies to \\(x \\in [x_0, x_1]\\). With this:</p> \\[ \\begin{equation} s(x) = \\sum_{k=0}^1 a_k x^k =  a_0 + a_1 x \\end{equation} \\] <p>and the coefficients can be rewritten to</p> \\[ \\begin{align} a_0 &amp;= (x_1 f(x_0) - x_0 f(x_1))/h, \\\\ a_1 &amp;= (f(x_1) - f(x_0))/h, \\end{align} \\] <p>where \\(h = x_1 - x_0\\).</p>"},{"location":"theory/linear/#2-dimensions","title":"<code>2</code> dimensions","text":"<p>For <code>2</code> dimensions the interval definition now reads \\(x \\in [{}^0x, {}^1x]^2\\). With this:</p> \\[ \\begin{equation} s(x_1, x_2) = \\sum_{k,l=0}^1 a_{kl} x_1^k x_2^l = a_{00} + a_{10}x_1 + a_{01}x_2 + a_{11}x_1x_2, \\end{equation} \\] <p>in which we're looking for the coefficients \\(a_{ij}\\) for \\(i,j=0,1\\). This can be accomplished by rewriting \\(\\eqref{eq:s_non_normalized}\\) for \\(N=2\\) using \\(\\eqref{eq:alpha0_non_normalized}\\) and \\(\\eqref{eq:alpha1_non_normalized}\\). To simplify the expressions we shall abbreviate \\(f_{ij} \\equiv f({}^ix_1,{}^jx_2)\\). With this \\(s(x_1,x_2)\\) reads</p> \\[ \\begin{align*} s(x_1,x_2) =&amp; \\sum_{i_1,i_2=0,1} f_{i_1i_2} \\alpha^{(1,0)}_{i_1} (x_1) \\alpha^{(1,0)}_{i_2} (x_2)\\\\  =&amp;~ \\frac{1}{h_1h_2}\\Bigl(\\underbrace{f_{00}\\gamma^{(0,0)}_1 \\gamma^{(0,0)}_2+        f_{01}\\gamma^{(0,0)}_1 \\gamma^{(1,0)}_2 +        f_{10}\\gamma^{(1,0)}_1 \\gamma^{(0,0)}_2 +        f_{11}\\gamma^{(1,0)}_1 \\gamma^{(1,0)}_2}_{a_{00}} + \\\\    &amp;~ \\underbrace{\\left( f_{00}\\gamma^{(0,1)}_1 \\gamma^{(0,0)}_2 +               f_{01}\\gamma^{(0,1)}_1 \\gamma^{(1,0)}_2 +               f_{10}\\gamma^{(1,1)}_1 \\gamma^{(0,0)}_2 +               f_{11}\\gamma^{(1,1)}_1 \\gamma^{(1,0)}_2 \\right)}_{a_{10}} x_1 +  \\\\    &amp;~ \\underbrace{\\left( f_{00}\\gamma^{(0,0)}_1 \\gamma^{(0,1)}_2 +               f_{01}\\gamma^{(0,0)}_1 \\gamma^{(1,1)}_2 +               f_{10}\\gamma^{(1,0)}_1 \\gamma^{(0,1)}_2 +               f_{11}\\gamma^{(1,0)}_1 \\gamma^{(1,1)}_2 \\right)}_{a_{01}} x_2 +  \\\\    &amp;~ \\underbrace{\\left( f_{00}\\gamma^{(0,1)}_1 \\gamma^{(0,1)}_2 +               f_{01}\\gamma^{(0,1)}_1 \\gamma^{(1,1)}_2 +               f_{10}\\gamma^{(1,1)}_1 \\gamma^{(0,1)}_2 +               f_{11}\\gamma^{(1,1)}_1 \\gamma^{(1,1)}_2 \\right)}_{a_{11}} x_1x_2\\Bigr)\\\\ \\end{align*} \\] <p>This eventually leads to the following coefficients:</p> \\[ \\begin{align*} a_{00} &amp;= \\left(f_{00}{}^1x_1 {}^1x_2 -                  f_{01}{}^1x_1 {}^0x_2 -                  f_{10}{}^0x_1 {}^1x_2 +                  f_{11}{}^0x_1 {}^0x_2 \\right)/h_1h_2\\\\ a_{10} &amp;= \\left(-f_{00}{}^1x_2 +                   f_{01}{}^0x_2 +                   f_{10}{}^1x_2 -                  f_{11}{}^0x_2 \\right)/h_1h_2\\\\ a_{01} &amp;= \\left(-f_{00}{}^1x_1 +                   f_{01}{}^1x_1 +                   f_{10}{}^0x_1 -                  f_{11}{}^0x_1 \\right)/h_1h_2\\\\ a_{11} &amp;= \\left( f_{00} -                   f_{01} -                   f_{10} +                  f_{11} \\right)/h_1h_2 \\end{align*} \\]"},{"location":"theory/linear/#n-dimensions","title":"<code>N</code> dimensions","text":"<p>For <code>N</code> dimensions, again the \\(\\alpha\\)-terms in equation \\(\\eqref{eq:s_non_normalized}\\) are now replaced with the expressions from \\(\\eqref{eq:alpha0_non_normalized}\\) and \\(\\eqref{eq:alpha1_non_normalized}\\):</p> \\[ s^{(n)}(x_1,\\dots,x_N) = \\sum_{i_1,\\dots,i_N=0,1} f({}^{i_1}x_1,\\dots,{}^{i_N}x_N) \\prod_{k=1}^N \\frac{1}{h_k}\\left( \\gamma^{(i_k,0)}_k + \\gamma^{(i_k,1)}_k x_k  \\right) \\] <p>Analogue to <code>2</code> dimensions, this expression needs to be reordered to terms with common combinations of \\(x_k\\)\u200b. One term for \\(x_1\\)\u200b, one for \\(x_2\\)\u200b, and so on, also terms combining multiple \\(x_k\\)'s. Then, each term will correspond to one the coefficients in \\(a_{i_1,\\dots,i_N}\\). Doing so leads to</p> \\[ s^{(n)}(x_1,\\dots,x_N) = \\sum_{J\\subseteq \\{1,\\dots,N\\}} c_J \\prod_{k\\in J} x_k, \\] <p>where</p> \\[ c_J = \\prod_{k=1}^N \\frac{1}{h_k} \\sum_{i_1,\\dots,i_N=0,1} f\\Bigl({}^{i_1}x_1,\\dots,{}^{i_N}x_N\\Bigr) \\prod_{k\\notin J} \\gamma^{(i_k,0)}_k \\prod_{k\\in J} \\gamma^{(i_k,1)}_k. \\] <p>Here, the symbol \\(J\\subseteq \\{1,\\dots,N\\}\\) means that \\(J\\) is any subset of \\(\\{1,\\dots,N\\}\\), including:</p> <ul> <li>The empty subset \\(J = \\emptyset\\).</li> <li>All singleton subsets like \\(J = \\{1\\}, J = \\{2\\},\\) etc.</li> <li>All pairs like \\(J = \\{1,2\\}, J = \\{1,3\\}, J = \\{2,3\\}\\), etc.</li> <li>And so on, up to the full set \\(J = \\{1,\\dots,N\\}\\).</li> </ul>"},{"location":"reference/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cip <ul> <li>class AkimaSpline1D </li> <li>class AkimaSpline2D </li> <li>class CubicCellND </li> <li>class CubicCellND&lt; T, 1 &gt; </li> <li>class CubicInterpND </li> <li>class CubicInterpND&lt; T, 1 &gt; </li> <li>class Indexer </li> <li>class LinearCellND </li> <li>class LinearCellND&lt; T, 1 &gt; </li> <li>class LinearInterp1D </li> <li>class LinearInterp2D </li> <li>class LinearInterp3D </li> <li>class LinearInterp4D </li> <li>class LinearInterpND </li> <li>class LinearInterpND&lt; T, 1 &gt; </li> <li>class MonotonicSpline1D </li> <li>class MonotonicSpline2D </li> <li>class NaturalSpline1D </li> <li>class NaturalSpline2D </li> <li>class NaturalSpline3D </li> <li>class VectorN </li> <li>struct setNaturalSplineBoundaryCondition </li> <li>struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt; </li> <li>struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt; </li> <li>struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt; </li> </ul> </li> <li>struct Flatten </li> <li>struct Flatten&lt; NestedVector, 1 &gt; </li> </ul>"},{"location":"reference/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>file cubic_spline.hpp </li> <li>file cubic_splines_1d.hpp </li> <li>file cubic_splines_2d.hpp </li> <li>file cubic_splines_3d.hpp </li> <li>file cubinterpp.hpp </li> <li>file derivatives.hpp </li> <li>file linear_interp.hpp </li> <li>file slopes.hpp </li> <li>file utils.hpp </li> <li>file vectorn.hpp </li> </ul> </li> <li>dir src <ul> <li>file cubinterpp_py_module.cpp </li> </ul> </li> </ul>"},{"location":"reference/namespacecip/","title":"Namespace cip","text":"<p>Namespace List &gt; cip</p>"},{"location":"reference/namespacecip/#classes","title":"Classes","text":"Type Name class AkimaSpline1D &lt;typename T, N&gt; class AkimaSpline2D &lt;typename T, N&gt; class CubicCellND &lt;typename T, N&gt; class CubicCellND&lt; T, 1 &gt; &lt;typename T&gt; class CubicInterpND &lt;typename T, N&gt; class CubicInterpND&lt; T, 1 &gt; &lt;typename T&gt; class Indexer &lt;typename T&gt; class LinearCellND &lt;typename T, N&gt; class LinearCellND&lt; T, 1 &gt; &lt;typename T&gt; class LinearInterp1D &lt;typename T&gt; class LinearInterp2D &lt;typename T&gt; class LinearInterp3D &lt;typename T&gt; class LinearInterp4D &lt;typename T&gt; class LinearInterpND &lt;typename T, N&gt; class LinearInterpND&lt; T, 1 &gt; &lt;typename T&gt; class MonotonicSpline1D &lt;typename T, N&gt; class MonotonicSpline2D &lt;typename T, N&gt; class NaturalSpline1D &lt;typename T, N, BC&gt; class NaturalSpline2D &lt;typename T, BC, N&gt; class NaturalSpline3D &lt;typename T, BC, N&gt; class VectorN &lt;typename T, N&gt; struct setNaturalSplineBoundaryCondition &lt;BC, typename T, typename Tx, typename Tf&gt; struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt; &lt;typename T, typename Tx, typename Tf&gt; struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt; &lt;typename T, typename Tx, typename Tf&gt; struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt; &lt;typename T, typename Tx, typename Tf&gt;"},{"location":"reference/namespacecip/#public-types","title":"Public Types","text":"Type Name enum BoundaryConditionType"},{"location":"reference/namespacecip/#public-attributes","title":"Public Attributes","text":"Type Name constexpr std::size_t SIZE_T_ZERO   = <code>0</code>"},{"location":"reference/namespacecip/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; T &gt; akima_slopes (const Tx x, const Tf f)  constexpr std::size_t binomial (std::size_t n, std::size_t k) noexcept T binomial_power_coefficient (const T y, const int n, const int k)  constexpr auto build_coordinate_indices (const Tuple &amp; t)  constexpr auto build_coordinate_indices_impl (const Tuple &amp; t, Accum acc)  void call_move_into_submdspan (FType &amp; F, SlopeType &amp;&amp; slopes, const CoordTuple &amp; coord, const DerivTuple &amp; deriv)  auto call_submdspan_1d (FType &amp; F, const CoordTuple &amp; coord, const DerivTuple &amp; deriv)  void compute_mixed_derivatives (FType &amp; F, XiArray const &amp; xi, CalcSlopesFunctor calcSlopes)  void compute_mixed_derivatives_impl (FType &amp; F, XiArray const &amp; xi, const DerivTuple &amp; currentDeriv, CalcSlopesFunctor calcSlopes, std::size_t start=0)  constexpr int factorial (int n)  constexpr void for_each_dimension (const Tuple &amp; tup, Func &amp;&amp; func)  constexpr void for_each_dimension_impl (const Tuple &amp; tup, Func &amp;&amp; func, std::index_sequence&lt; Is... &gt;)  void iterate_over_indices (Func &amp;&amp; func, XiArray const &amp; xi, Indices... indices)  constexpr auto make_zero_tuple ()  std::vector&lt; T &gt; monotonic_slopes (const Tx x, const Tf f)  std::vector&lt; T &gt; natural_spline_slopes (const Tx x, const Tf f)  constexpr std::size_t power ()  void thomas_algorithm (const std::vector&lt; T &gt; &amp; a, const std::vector&lt; T &gt; &amp; b, std::vector&lt; T &gt; &amp; c, std::vector&lt; T &gt; &amp; d)  constexpr auto update_tuple_element (const Tuple &amp; tup, T new_value)"},{"location":"reference/namespacecip/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"reference/namespacecip/#enum-boundaryconditiontype","title":"enum BoundaryConditionType","text":"<pre><code>enum cip::BoundaryConditionType {\n    Natural,\n    Clamped,\n    NotAKnot\n};\n</code></pre>"},{"location":"reference/namespacecip/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"reference/namespacecip/#variable-size_t_zero","title":"variable SIZE_T_ZERO","text":"<pre><code>constexpr std::size_t cip::SIZE_T_ZERO;\n</code></pre>"},{"location":"reference/namespacecip/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/namespacecip/#function-akima_slopes","title":"function akima_slopes","text":"<pre><code>template&lt;typename T, typename Tx, typename Tf&gt;\nstd::vector&lt; T &gt; cip::akima_slopes (\n    const Tx x,\n    const Tf f\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-binomial","title":"function binomial","text":"<pre><code>inline constexpr std::size_t cip::binomial (\n    std::size_t n,\n    std::size_t k\n) noexcept\n</code></pre>"},{"location":"reference/namespacecip/#function-binomial_power_coefficient","title":"function binomial_power_coefficient","text":"<pre><code>template&lt;typename T&gt;\nT cip::binomial_power_coefficient (\n    const T y,\n    const int n,\n    const int k\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-build_coordinate_indices","title":"function build_coordinate_indices","text":"<pre><code>template&lt;std::size_t N, std::size_t D, typename Tuple&gt;\nconstexpr auto cip::build_coordinate_indices (\n    const Tuple &amp; t\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-build_coordinate_indices_impl","title":"function build_coordinate_indices_impl","text":"<pre><code>template&lt;std::size_t I, std::size_t N, std::size_t D, typename Tuple, typename Accum&gt;\nconstexpr auto cip::build_coordinate_indices_impl (\n    const Tuple &amp; t,\n    Accum acc\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-call_move_into_submdspan","title":"function call_move_into_submdspan","text":"<pre><code>template&lt;typename FType, typename SlopeType, typename CoordTuple, typename DerivTuple&gt;\nvoid cip::call_move_into_submdspan (\n    FType &amp; F,\n    SlopeType &amp;&amp; slopes,\n    const CoordTuple &amp; coord,\n    const DerivTuple &amp; deriv\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-call_submdspan_1d","title":"function call_submdspan_1d","text":"<pre><code>template&lt;typename FType, typename CoordTuple, typename DerivTuple&gt;\nauto cip::call_submdspan_1d (\n    FType &amp; F,\n    const CoordTuple &amp; coord,\n    const DerivTuple &amp; deriv\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-compute_mixed_derivatives","title":"function compute_mixed_derivatives","text":"<pre><code>template&lt;std::size_t N, typename FType, typename XiArray, typename CalcSlopesFunctor&gt;\nvoid cip::compute_mixed_derivatives (\n    FType &amp; F,\n    XiArray const &amp; xi,\n    CalcSlopesFunctor calcSlopes\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-compute_mixed_derivatives_impl","title":"function compute_mixed_derivatives_impl","text":"<pre><code>template&lt;std::size_t N, typename FType, typename XiArray, typename DerivTuple, typename CalcSlopesFunctor&gt;\nvoid cip::compute_mixed_derivatives_impl (\n    FType &amp; F,\n    XiArray const &amp; xi,\n    const DerivTuple &amp; currentDeriv,\n    CalcSlopesFunctor calcSlopes,\n    std::size_t start=0\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-factorial","title":"function factorial","text":"<pre><code>inline constexpr int cip::factorial (\n    int n\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-for_each_dimension","title":"function for_each_dimension","text":"<pre><code>template&lt;std::size_t N, typename Tuple, typename Func&gt;\nconstexpr void cip::for_each_dimension (\n    const Tuple &amp; tup,\n    Func &amp;&amp; func\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-for_each_dimension_impl","title":"function for_each_dimension_impl","text":"<pre><code>template&lt;std::size_t N, typename Tuple, typename Func, std::size_t... Is&gt;\nconstexpr void cip::for_each_dimension_impl (\n    const Tuple &amp; tup,\n    Func &amp;&amp; func,\n    std::index_sequence&lt; Is... &gt;\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-iterate_over_indices","title":"function iterate_over_indices","text":"<pre><code>template&lt;std::size_t N, std::size_t D, std::size_t current, typename Func, typename XiArray, typename... Indices&gt;\nvoid cip::iterate_over_indices (\n    Func &amp;&amp; func,\n    XiArray const &amp; xi,\n    Indices... indices\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-make_zero_tuple","title":"function make_zero_tuple","text":"<pre><code>template&lt;std::size_t N&gt;\nconstexpr auto cip::make_zero_tuple () \n</code></pre>"},{"location":"reference/namespacecip/#function-monotonic_slopes","title":"function monotonic_slopes","text":"<pre><code>template&lt;typename T, typename Tx, typename Tf&gt;\nstd::vector&lt; T &gt; cip::monotonic_slopes (\n    const Tx x,\n    const Tf f\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-natural_spline_slopes","title":"function natural_spline_slopes","text":"<pre><code>template&lt;typename T, BoundaryConditionType BC, typename Tx, typename Tf&gt;\nstd::vector&lt; T &gt; cip::natural_spline_slopes (\n    const Tx x,\n    const Tf f\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-power","title":"function power","text":"<pre><code>template&lt;std::size_t Base, std::size_t Exp&gt;\nconstexpr std::size_t cip::power () \n</code></pre>"},{"location":"reference/namespacecip/#function-thomas_algorithm","title":"function thomas_algorithm","text":"<pre><code>template&lt;typename T&gt;\nvoid cip::thomas_algorithm (\n    const std::vector&lt; T &gt; &amp; a,\n    const std::vector&lt; T &gt; &amp; b,\n    std::vector&lt; T &gt; &amp; c,\n    std::vector&lt; T &gt; &amp; d\n) \n</code></pre>"},{"location":"reference/namespacecip/#function-update_tuple_element","title":"function update_tuple_element","text":"<pre><code>template&lt;std::size_t D, typename Tuple, typename T&gt;\nconstexpr auto cip::update_tuple_element (\n    const Tuple &amp; tup,\n    T new_value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_spline.hpp</code></p>"},{"location":"reference/classcip_1_1AkimaSpline1D/","title":"Class cip::AkimaSpline1D","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; AkimaSpline1D</p> <p>Inherits the following classes: cip::CubicInterpND</p>"},{"location":"reference/classcip_1_1AkimaSpline1D/#public-functions","title":"Public Functions","text":"Type Name AkimaSpline1D (const Vector &amp; x, const Vector &amp; f)  Vector calc_slopes (const Vector &amp; x, const Vector &amp; f) override const ~AkimaSpline1D ()"},{"location":"reference/classcip_1_1AkimaSpline1D/#public-functions-inherited-from-cipcubicinterpnd","title":"Public Functions inherited from cip::CubicInterpND","text":"<p>See cip::CubicInterpND</p> Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1AkimaSpline1D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1AkimaSpline1D/#function-akimaspline1d","title":"function AkimaSpline1D","text":"<pre><code>inline cip::AkimaSpline1D::AkimaSpline1D (\n    const Vector &amp; x,\n    const Vector &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1AkimaSpline1D/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>inline Vector cip::AkimaSpline1D::calc_slopes (\n    const Vector &amp; x,\n    const Vector &amp; f\n) override const\n</code></pre>"},{"location":"reference/classcip_1_1AkimaSpline1D/#function-akimaspline1d_1","title":"function ~AkimaSpline1D","text":"<pre><code>inline cip::AkimaSpline1D::~AkimaSpline1D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_splines_1d.hpp</code></p>"},{"location":"reference/classcip_1_1AkimaSpline2D/","title":"Class cip::AkimaSpline2D","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; AkimaSpline2D</p> <p>Inherits the following classes: cip::CubicInterpND</p>"},{"location":"reference/classcip_1_1AkimaSpline2D/#public-functions","title":"Public Functions","text":"Type Name AkimaSpline2D (const Vector &amp; _x, const Vector &amp; _y, const VectorN &amp; _f)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) override const ~AkimaSpline2D ()"},{"location":"reference/classcip_1_1AkimaSpline2D/#public-functions-inherited-from-cipcubicinterpnd","title":"Public Functions inherited from cip::CubicInterpND","text":"<p>See cip::CubicInterpND</p> Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1AkimaSpline2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1AkimaSpline2D/#function-akimaspline2d","title":"function AkimaSpline2D","text":"<pre><code>inline cip::AkimaSpline2D::AkimaSpline2D (\n    const Vector &amp; _x,\n    const Vector &amp; _y,\n    const VectorN &amp; _f\n) \n</code></pre>"},{"location":"reference/classcip_1_1AkimaSpline2D/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>inline virtual Vector cip::AkimaSpline2D::calc_slopes (\n    const Vector &amp; x,\n    const Mdspan1D &amp; f\n) override const\n</code></pre> <p>Implements cip::CubicInterpND::calc_slopes</p>"},{"location":"reference/classcip_1_1AkimaSpline2D/#function-akimaspline2d_1","title":"function ~AkimaSpline2D","text":"<pre><code>inline cip::AkimaSpline2D::~AkimaSpline2D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_splines_2d.hpp</code></p>"},{"location":"reference/classcip_1_1CubicCellND/","title":"Class cip::CubicCellND","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; CubicCellND</p>"},{"location":"reference/classcip_1_1CubicCellND/#public-functions","title":"Public Functions","text":"Type Name CubicCellND (const Mdspan &amp; F, const Spans &amp; x)  T eval (Args &amp;&amp;... xi) const ~CubicCellND () = default"},{"location":"reference/classcip_1_1CubicCellND/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1CubicCellND/#function-cubiccellnd","title":"function CubicCellND","text":"<pre><code>inline explicit cip::CubicCellND::CubicCellND (\n    const Mdspan &amp; F,\n    const Spans &amp; x\n) \n</code></pre>"},{"location":"reference/classcip_1_1CubicCellND/#function-eval","title":"function eval","text":"<pre><code>template&lt;typename... Args&gt;\ninline T cip::CubicCellND::eval (\n    Args &amp;&amp;... xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1CubicCellND/#function-cubiccellnd_1","title":"function ~CubicCellND","text":"<pre><code>cip::CubicCellND::~CubicCellND () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_spline.hpp</code></p>"},{"location":"reference/classcip_1_1CubicCellND_3_01T_00_011_01_4/","title":"Class cip::CubicCellND&lt; T, 1 &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; CubicCellND&lt; T, 1 &gt;</p>"},{"location":"reference/classcip_1_1CubicCellND_3_01T_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name CubicCellND (const Span &amp; x, const Mdspan &amp; F)  const T eval (const T x) const ~CubicCellND () = default"},{"location":"reference/classcip_1_1CubicCellND_3_01T_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1CubicCellND_3_01T_00_011_01_4/#function-cubiccellnd","title":"function CubicCellND","text":"<pre><code>inline explicit cip::CubicCellND&lt; T, 1 &gt;::CubicCellND (\n    const Span &amp; x,\n    const Mdspan &amp; F\n) \n</code></pre>"},{"location":"reference/classcip_1_1CubicCellND_3_01T_00_011_01_4/#function-eval","title":"function eval","text":"<pre><code>inline const T cip::CubicCellND&lt; T, 1 &gt;::eval (\n    const T x\n) const\n</code></pre>"},{"location":"reference/classcip_1_1CubicCellND_3_01T_00_011_01_4/#function-cubiccellnd_1","title":"function ~CubicCellND","text":"<pre><code>cip::CubicCellND&lt; T, 1 &gt;::~CubicCellND () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_spline.hpp</code></p>"},{"location":"reference/classcip_1_1CubicInterpND/","title":"Class cip::CubicInterpND","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; CubicInterpND</p> <p>Inherited by the following classes: cip::AkimaSpline1D,  cip::AkimaSpline2D,  cip::MonotonicSpline1D,  cip::MonotonicSpline2D,  cip::NaturalSpline1D,  cip::NaturalSpline2D,  cip::NaturalSpline3D</p>"},{"location":"reference/classcip_1_1CubicInterpND/#public-functions","title":"Public Functions","text":"Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1CubicInterpND/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1CubicInterpND/#function-cubicinterpnd","title":"function CubicInterpND","text":"<pre><code>template&lt;typename... Args&gt;\ninline cip::CubicInterpND::CubicInterpND (\n    const Ff &amp; _f,\n    const Args &amp;... _xi\n) \n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND/#function-build","title":"function build","text":"<pre><code>template&lt;typename... Args&gt;\ninline void cip::CubicInterpND::build (\n    const Ff &amp; f,\n    const Args &amp;... _xi\n) \n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>virtual Vector cip::CubicInterpND::calc_slopes (\n    const Vector &amp; x,\n    const Mdspan1D &amp; f\n) const = 0\n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND/#function-eval","title":"function eval","text":"<pre><code>template&lt;typename... Args&gt;\ninline T cip::CubicInterpND::eval (\n    const Args &amp;... args\n) const\n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND/#function-cubicinterpnd_1","title":"function ~CubicInterpND","text":"<pre><code>inline virtual cip::CubicInterpND::~CubicInterpND () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_spline.hpp</code></p>"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/","title":"Class cip::CubicInterpND&lt; T, 1 &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; CubicInterpND&lt; T, 1 &gt;</p>"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name CubicInterpND (const Vector &amp; _x, const Vector &amp; _f)  void build (Vector f)  virtual Vector calc_slopes (const Vector &amp; x, const Vector &amp; f) const = 0 T eval (const T xi) const Vector evaln (const Vector &amp; xi) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#function-cubicinterpnd","title":"function CubicInterpND","text":"<pre><code>inline cip::CubicInterpND&lt; T, 1 &gt;::CubicInterpND (\n    const Vector &amp; _x,\n    const Vector &amp; _f\n) \n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#function-build","title":"function build","text":"<pre><code>inline void cip::CubicInterpND&lt; T, 1 &gt;::build (\n    Vector f\n) \n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>virtual Vector cip::CubicInterpND&lt; T, 1 &gt;::calc_slopes (\n    const Vector &amp; x,\n    const Vector &amp; f\n) const = 0\n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#function-eval","title":"function eval","text":"<pre><code>inline T cip::CubicInterpND&lt; T, 1 &gt;::eval (\n    const T xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#function-evaln","title":"function evaln","text":"<pre><code>inline Vector cip::CubicInterpND&lt; T, 1 &gt;::evaln (\n    const Vector &amp; xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1CubicInterpND_3_01T_00_011_01_4/#function-cubicinterpnd_1","title":"function ~CubicInterpND","text":"<pre><code>inline virtual cip::CubicInterpND&lt; T, 1 &gt;::~CubicInterpND () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_spline.hpp</code></p>"},{"location":"reference/classcip_1_1Indexer/","title":"Class cip::Indexer","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; Indexer</p>"},{"location":"reference/classcip_1_1Indexer/#public-functions","title":"Public Functions","text":"Type Name Indexer (const Vector &amp; _x)  const std::size_t cell_index (const T xi) const const std::size_t sort_index (const T xi) const ~Indexer ()"},{"location":"reference/classcip_1_1Indexer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1Indexer/#function-indexer","title":"function Indexer","text":"<pre><code>inline cip::Indexer::Indexer (\n    const Vector &amp; _x\n) \n</code></pre>"},{"location":"reference/classcip_1_1Indexer/#function-cell_index","title":"function cell_index","text":"<pre><code>inline const std::size_t cip::Indexer::cell_index (\n    const T xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1Indexer/#function-sort_index","title":"function sort_index","text":"<pre><code>inline const std::size_t cip::Indexer::sort_index (\n    const T xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1Indexer/#function-indexer_1","title":"function ~Indexer","text":"<pre><code>inline cip::Indexer::~Indexer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/utils.hpp</code></p>"},{"location":"reference/classcip_1_1LinearCellND/","title":"Class cip::LinearCellND","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; LinearCellND</p>"},{"location":"reference/classcip_1_1LinearCellND/#public-functions","title":"Public Functions","text":"Type Name LinearCellND (const Mdspan &amp; _f, const Spans &amp; _x)  T eval (Args &amp;&amp;... args) const"},{"location":"reference/classcip_1_1LinearCellND/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearCellND/#function-linearcellnd","title":"function LinearCellND","text":"<pre><code>inline explicit cip::LinearCellND::LinearCellND (\n    const Mdspan &amp; _f,\n    const Spans &amp; _x\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearCellND/#function-eval","title":"function eval","text":"<pre><code>template&lt;typename... Args&gt;\ninline T cip::LinearCellND::eval (\n    Args &amp;&amp;... args\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1LinearCellND_3_01T_00_011_01_4/","title":"Class cip::LinearCellND&lt; T, 1 &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; LinearCellND&lt; T, 1 &gt;</p>"},{"location":"reference/classcip_1_1LinearCellND_3_01T_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name LinearCellND (Span x, Span f)  T eval (const T &amp; xi) const ~LinearCellND ()"},{"location":"reference/classcip_1_1LinearCellND_3_01T_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearCellND_3_01T_00_011_01_4/#function-linearcellnd","title":"function LinearCellND","text":"<pre><code>inline explicit cip::LinearCellND&lt; T, 1 &gt;::LinearCellND (\n    Span x,\n    Span f\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearCellND_3_01T_00_011_01_4/#function-eval","title":"function eval","text":"<pre><code>inline T cip::LinearCellND&lt; T, 1 &gt;::eval (\n    const T &amp; xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1LinearCellND_3_01T_00_011_01_4/#function-linearcellnd_1","title":"function ~LinearCellND","text":"<pre><code>inline cip::LinearCellND&lt; T, 1 &gt;::~LinearCellND () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1LinearInterp1D/","title":"Class cip::LinearInterp1D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; LinearInterp1D</p> <p>Inherits the following classes: cip::LinearInterpND&lt; T, 1 &gt;</p>"},{"location":"reference/classcip_1_1LinearInterp1D/#public-functions","title":"Public Functions","text":"Type Name LinearInterp1D (const Vector &amp; x, const Vector &amp; f)  ~LinearInterp1D ()"},{"location":"reference/classcip_1_1LinearInterp1D/#public-functions-inherited-from-ciplinearinterpnd-t-1","title":"Public Functions inherited from cip::LinearInterpND&lt; T, 1 &gt;","text":"<p>See cip::LinearInterpND&lt; T, 1 &gt;</p> Type Name LinearInterpND (const Vector &amp; _f, const Vector &amp; _x)  void build (const Vector &amp; x, const Vector &amp; f)  T eval (const T xi) const Vector evaln (const Vector &amp; xi) const ~LinearInterpND ()"},{"location":"reference/classcip_1_1LinearInterp1D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearInterp1D/#function-linearinterp1d","title":"function LinearInterp1D","text":"<pre><code>inline explicit cip::LinearInterp1D::LinearInterp1D (\n    const Vector &amp; x,\n    const Vector &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearInterp1D/#function-linearinterp1d_1","title":"function ~LinearInterp1D","text":"<pre><code>inline cip::LinearInterp1D::~LinearInterp1D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1LinearInterp2D/","title":"Class cip::LinearInterp2D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; LinearInterp2D</p> <p>Inherits the following classes: cip::LinearInterpND</p>"},{"location":"reference/classcip_1_1LinearInterp2D/#public-functions","title":"Public Functions","text":"Type Name LinearInterp2D (const Vector &amp; x, const Vector &amp; y, const Vector2 &amp; f)  ~LinearInterp2D ()"},{"location":"reference/classcip_1_1LinearInterp2D/#public-functions-inherited-from-ciplinearinterpnd","title":"Public Functions inherited from cip::LinearInterpND","text":"<p>See cip::LinearInterpND</p> Type Name LinearInterpND (const F &amp; _f, const Args &amp;... _xi)  T eval (const Args &amp;... args) const Vector evaln (const Vectors &amp;... inputs) const ~LinearInterpND ()"},{"location":"reference/classcip_1_1LinearInterp2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearInterp2D/#function-linearinterp2d","title":"function LinearInterp2D","text":"<pre><code>inline explicit cip::LinearInterp2D::LinearInterp2D (\n    const Vector &amp; x,\n    const Vector &amp; y,\n    const Vector2 &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearInterp2D/#function-linearinterp2d_1","title":"function ~LinearInterp2D","text":"<pre><code>inline cip::LinearInterp2D::~LinearInterp2D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1LinearInterp3D/","title":"Class cip::LinearInterp3D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; LinearInterp3D</p> <p>Inherits the following classes: cip::LinearInterpND</p>"},{"location":"reference/classcip_1_1LinearInterp3D/#public-functions","title":"Public Functions","text":"Type Name LinearInterp3D (const Vector &amp; x, const Vector &amp; y, const Vector &amp; z, const Vector3 &amp; f)  ~LinearInterp3D ()"},{"location":"reference/classcip_1_1LinearInterp3D/#public-functions-inherited-from-ciplinearinterpnd","title":"Public Functions inherited from cip::LinearInterpND","text":"<p>See cip::LinearInterpND</p> Type Name LinearInterpND (const F &amp; _f, const Args &amp;... _xi)  T eval (const Args &amp;... args) const Vector evaln (const Vectors &amp;... inputs) const ~LinearInterpND ()"},{"location":"reference/classcip_1_1LinearInterp3D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearInterp3D/#function-linearinterp3d","title":"function LinearInterp3D","text":"<pre><code>inline explicit cip::LinearInterp3D::LinearInterp3D (\n    const Vector &amp; x,\n    const Vector &amp; y,\n    const Vector &amp; z,\n    const Vector3 &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearInterp3D/#function-linearinterp3d_1","title":"function ~LinearInterp3D","text":"<pre><code>inline cip::LinearInterp3D::~LinearInterp3D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1LinearInterp4D/","title":"Class cip::LinearInterp4D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; LinearInterp4D</p> <p>Inherits the following classes: cip::LinearInterpND</p>"},{"location":"reference/classcip_1_1LinearInterp4D/#public-functions","title":"Public Functions","text":"Type Name LinearInterp4D (const Vector &amp; x, const Vector &amp; y, const Vector &amp; z, const Vector &amp; w, const Vector4 &amp; f)  ~LinearInterp4D ()"},{"location":"reference/classcip_1_1LinearInterp4D/#public-functions-inherited-from-ciplinearinterpnd","title":"Public Functions inherited from cip::LinearInterpND","text":"<p>See cip::LinearInterpND</p> Type Name LinearInterpND (const F &amp; _f, const Args &amp;... _xi)  T eval (const Args &amp;... args) const Vector evaln (const Vectors &amp;... inputs) const ~LinearInterpND ()"},{"location":"reference/classcip_1_1LinearInterp4D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearInterp4D/#function-linearinterp4d","title":"function LinearInterp4D","text":"<pre><code>inline explicit cip::LinearInterp4D::LinearInterp4D (\n    const Vector &amp; x,\n    const Vector &amp; y,\n    const Vector &amp; z,\n    const Vector &amp; w,\n    const Vector4 &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearInterp4D/#function-linearinterp4d_1","title":"function ~LinearInterp4D","text":"<pre><code>inline cip::LinearInterp4D::~LinearInterp4D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1LinearInterpND/","title":"Class cip::LinearInterpND","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; LinearInterpND</p>"},{"location":"reference/classcip_1_1LinearInterpND/#public-functions","title":"Public Functions","text":"Type Name LinearInterpND (const F &amp; _f, const Args &amp;... _xi)  T eval (const Args &amp;... args) const Vector evaln (const Vectors &amp;... inputs) const ~LinearInterpND ()"},{"location":"reference/classcip_1_1LinearInterpND/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearInterpND/#function-linearinterpnd","title":"function LinearInterpND","text":"<pre><code>template&lt;typename... Args&gt;\ninline cip::LinearInterpND::LinearInterpND (\n    const F &amp; _f,\n    const Args &amp;... _xi\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearInterpND/#function-eval","title":"function eval","text":"<pre><code>template&lt;typename... Args&gt;\ninline T cip::LinearInterpND::eval (\n    const Args &amp;... args\n) const\n</code></pre>"},{"location":"reference/classcip_1_1LinearInterpND/#function-evaln","title":"function evaln","text":"<pre><code>template&lt;typename... Vectors&gt;\ninline Vector cip::LinearInterpND::evaln (\n    const Vectors &amp;... inputs\n) const\n</code></pre>"},{"location":"reference/classcip_1_1LinearInterpND/#function-linearinterpnd_1","title":"function ~LinearInterpND","text":"<pre><code>inline cip::LinearInterpND::~LinearInterpND () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/","title":"Class cip::LinearInterpND&lt; T, 1 &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cip &gt; LinearInterpND&lt; T, 1 &gt;</p> <p>Inherited by the following classes: cip::LinearInterp1D</p>"},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/#public-functions","title":"Public Functions","text":"Type Name LinearInterpND (const Vector &amp; _f, const Vector &amp; _x)  void build (const Vector &amp; x, const Vector &amp; f)  T eval (const T xi) const Vector evaln (const Vector &amp; xi) const ~LinearInterpND ()"},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/#function-linearinterpnd","title":"function LinearInterpND","text":"<pre><code>inline cip::LinearInterpND&lt; T, 1 &gt;::LinearInterpND (\n    const Vector &amp; _f,\n    const Vector &amp; _x\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/#function-build","title":"function build","text":"<pre><code>inline void cip::LinearInterpND&lt; T, 1 &gt;::build (\n    const Vector &amp; x,\n    const Vector &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/#function-eval","title":"function eval","text":"<pre><code>inline T cip::LinearInterpND&lt; T, 1 &gt;::eval (\n    const T xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/#function-evaln","title":"function evaln","text":"<pre><code>inline Vector cip::LinearInterpND&lt; T, 1 &gt;::evaln (\n    const Vector &amp; xi\n) const\n</code></pre>"},{"location":"reference/classcip_1_1LinearInterpND_3_01T_00_011_01_4/#function-linearinterpnd_1","title":"function ~LinearInterpND","text":"<pre><code>inline cip::LinearInterpND&lt; T, 1 &gt;::~LinearInterpND () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/classcip_1_1MonotonicSpline1D/","title":"Class cip::MonotonicSpline1D","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; MonotonicSpline1D</p> <p>Inherits the following classes: cip::CubicInterpND</p>"},{"location":"reference/classcip_1_1MonotonicSpline1D/#public-functions","title":"Public Functions","text":"Type Name MonotonicSpline1D (const Vector &amp; x, const Vector &amp; f)  Vector calc_slopes (const Vector &amp; x, const Vector &amp; f) override const ~MonotonicSpline1D ()"},{"location":"reference/classcip_1_1MonotonicSpline1D/#public-functions-inherited-from-cipcubicinterpnd","title":"Public Functions inherited from cip::CubicInterpND","text":"<p>See cip::CubicInterpND</p> Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1MonotonicSpline1D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1MonotonicSpline1D/#function-monotonicspline1d","title":"function MonotonicSpline1D","text":"<pre><code>inline cip::MonotonicSpline1D::MonotonicSpline1D (\n    const Vector &amp; x,\n    const Vector &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1MonotonicSpline1D/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>inline Vector cip::MonotonicSpline1D::calc_slopes (\n    const Vector &amp; x,\n    const Vector &amp; f\n) override const\n</code></pre>"},{"location":"reference/classcip_1_1MonotonicSpline1D/#function-monotonicspline1d_1","title":"function ~MonotonicSpline1D","text":"<pre><code>inline cip::MonotonicSpline1D::~MonotonicSpline1D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_splines_1d.hpp</code></p>"},{"location":"reference/classcip_1_1MonotonicSpline2D/","title":"Class cip::MonotonicSpline2D","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; MonotonicSpline2D</p> <p>Inherits the following classes: cip::CubicInterpND</p>"},{"location":"reference/classcip_1_1MonotonicSpline2D/#public-functions","title":"Public Functions","text":"Type Name MonotonicSpline2D (const Vector &amp; _x, const Vector &amp; _y, const VectorN &amp; _f)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) override const ~MonotonicSpline2D ()"},{"location":"reference/classcip_1_1MonotonicSpline2D/#public-functions-inherited-from-cipcubicinterpnd","title":"Public Functions inherited from cip::CubicInterpND","text":"<p>See cip::CubicInterpND</p> Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1MonotonicSpline2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1MonotonicSpline2D/#function-monotonicspline2d","title":"function MonotonicSpline2D","text":"<pre><code>inline cip::MonotonicSpline2D::MonotonicSpline2D (\n    const Vector &amp; _x,\n    const Vector &amp; _y,\n    const VectorN &amp; _f\n) \n</code></pre>"},{"location":"reference/classcip_1_1MonotonicSpline2D/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>inline virtual Vector cip::MonotonicSpline2D::calc_slopes (\n    const Vector &amp; x,\n    const Mdspan1D &amp; f\n) override const\n</code></pre> <p>Implements cip::CubicInterpND::calc_slopes</p>"},{"location":"reference/classcip_1_1MonotonicSpline2D/#function-monotonicspline2d_1","title":"function ~MonotonicSpline2D","text":"<pre><code>inline cip::MonotonicSpline2D::~MonotonicSpline2D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_splines_2d.hpp</code></p>"},{"location":"reference/classcip_1_1NaturalSpline1D/","title":"Class cip::NaturalSpline1D","text":"<p>template &lt;typename T, std::size_t N, cip::BoundaryConditionType BC&gt;</p> <p>ClassList &gt; cip &gt; NaturalSpline1D</p> <p>Inherits the following classes: cip::CubicInterpND</p>"},{"location":"reference/classcip_1_1NaturalSpline1D/#public-functions","title":"Public Functions","text":"Type Name NaturalSpline1D (const Vector &amp; x, const Vector &amp; f)  Vector calc_slopes (const Vector &amp; x, const Vector &amp; f) override const ~NaturalSpline1D ()"},{"location":"reference/classcip_1_1NaturalSpline1D/#public-functions-inherited-from-cipcubicinterpnd","title":"Public Functions inherited from cip::CubicInterpND","text":"<p>See cip::CubicInterpND</p> Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1NaturalSpline1D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1NaturalSpline1D/#function-naturalspline1d","title":"function NaturalSpline1D","text":"<pre><code>inline cip::NaturalSpline1D::NaturalSpline1D (\n    const Vector &amp; x,\n    const Vector &amp; f\n) \n</code></pre>"},{"location":"reference/classcip_1_1NaturalSpline1D/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>inline Vector cip::NaturalSpline1D::calc_slopes (\n    const Vector &amp; x,\n    const Vector &amp; f\n) override const\n</code></pre>"},{"location":"reference/classcip_1_1NaturalSpline1D/#function-naturalspline1d_1","title":"function ~NaturalSpline1D","text":"<pre><code>inline cip::NaturalSpline1D::~NaturalSpline1D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_splines_1d.hpp</code></p>"},{"location":"reference/classcip_1_1NaturalSpline2D/","title":"Class cip::NaturalSpline2D","text":"<p>template &lt;typename T, cip::BoundaryConditionType BC, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; NaturalSpline2D</p> <p>Inherits the following classes: cip::CubicInterpND</p>"},{"location":"reference/classcip_1_1NaturalSpline2D/#public-functions","title":"Public Functions","text":"Type Name NaturalSpline2D (const Vector &amp; _x, const Vector &amp; _y, const VectorN &amp; _f)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) override const ~NaturalSpline2D ()"},{"location":"reference/classcip_1_1NaturalSpline2D/#public-functions-inherited-from-cipcubicinterpnd","title":"Public Functions inherited from cip::CubicInterpND","text":"<p>See cip::CubicInterpND</p> Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1NaturalSpline2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1NaturalSpline2D/#function-naturalspline2d","title":"function NaturalSpline2D","text":"<pre><code>inline cip::NaturalSpline2D::NaturalSpline2D (\n    const Vector &amp; _x,\n    const Vector &amp; _y,\n    const VectorN &amp; _f\n) \n</code></pre>"},{"location":"reference/classcip_1_1NaturalSpline2D/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>inline virtual Vector cip::NaturalSpline2D::calc_slopes (\n    const Vector &amp; x,\n    const Mdspan1D &amp; f\n) override const\n</code></pre> <p>Implements cip::CubicInterpND::calc_slopes</p>"},{"location":"reference/classcip_1_1NaturalSpline2D/#function-naturalspline2d_1","title":"function ~NaturalSpline2D","text":"<pre><code>inline cip::NaturalSpline2D::~NaturalSpline2D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_splines_2d.hpp</code></p>"},{"location":"reference/classcip_1_1NaturalSpline3D/","title":"Class cip::NaturalSpline3D","text":"<p>template &lt;typename T, cip::BoundaryConditionType BC, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; NaturalSpline3D</p> <p>Inherits the following classes: cip::CubicInterpND</p>"},{"location":"reference/classcip_1_1NaturalSpline3D/#public-functions","title":"Public Functions","text":"Type Name NaturalSpline3D (const Vector &amp; _x, const Vector &amp; _y, const Vector &amp; _z, const VectorN &amp; _f)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) override const ~NaturalSpline3D ()"},{"location":"reference/classcip_1_1NaturalSpline3D/#public-functions-inherited-from-cipcubicinterpnd","title":"Public Functions inherited from cip::CubicInterpND","text":"<p>See cip::CubicInterpND</p> Type Name CubicInterpND (const Ff &amp; _f, const Args &amp;... _xi)  void build (const Ff &amp; f, const Args &amp;... _xi)  virtual Vector calc_slopes (const Vector &amp; x, const Mdspan1D &amp; f) const = 0 T eval (const Args &amp;... args) const virtual ~CubicInterpND ()"},{"location":"reference/classcip_1_1NaturalSpline3D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1NaturalSpline3D/#function-naturalspline3d","title":"function NaturalSpline3D","text":"<pre><code>inline cip::NaturalSpline3D::NaturalSpline3D (\n    const Vector &amp; _x,\n    const Vector &amp; _y,\n    const Vector &amp; _z,\n    const VectorN &amp; _f\n) \n</code></pre>"},{"location":"reference/classcip_1_1NaturalSpline3D/#function-calc_slopes","title":"function calc_slopes","text":"<pre><code>inline virtual Vector cip::NaturalSpline3D::calc_slopes (\n    const Vector &amp; x,\n    const Mdspan1D &amp; f\n) override const\n</code></pre> <p>Implements cip::CubicInterpND::calc_slopes</p>"},{"location":"reference/classcip_1_1NaturalSpline3D/#function-naturalspline3d_1","title":"function ~NaturalSpline3D","text":"<pre><code>inline cip::NaturalSpline3D::~NaturalSpline3D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/cubic_splines_3d.hpp</code></p>"},{"location":"reference/classcip_1_1VectorN/","title":"Class cip::VectorN","text":"<p>template &lt;typename T, std::size_t N&gt;</p> <p>ClassList &gt; cip &gt; VectorN</p>"},{"location":"reference/classcip_1_1VectorN/#public-functions","title":"Public Functions","text":"Type Name VectorN (const T &amp; initial_value, const IndexArray &amp; dimensions)  VectorN (const VectorN &amp; other)  VectorN (const NestedVector &amp; nested)  VectorN (const IndexArray &amp; dimensions)  const std::vector&lt; T &gt; &amp; data () const const IndexArray &amp; dimensions () const void emplace_back (Args... args)  Mdspan get_mdspan ()  const Mdspan get_mdspan () const void move_into_submdspan (std::vector&lt; T &gt; &amp;&amp; source, SliceSpecs &amp;&amp;... specs)  void move_into_submdspan (VectorN&lt; T, M &gt; &amp;&amp; source, SliceSpecs &amp;&amp;... specs)  T &amp; operator() (Indices... indices)  const T &amp; operator() (Indices... indices) const T &amp; operator() (IndexArray &amp; indices)  const T &amp; operator() (IndexArray &amp; indices) const Mdspan submdspan (Pairs &amp;&amp;... pairs) const Mdspan submdspan (Pairs &amp;&amp;... pairs)  Mdspan1D submdspan_1d (SliceArgs &amp;&amp;... args)"},{"location":"reference/classcip_1_1VectorN/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/classcip_1_1VectorN/#function-vectorn-14","title":"function VectorN [1/4]","text":"<pre><code>inline cip::VectorN::VectorN (\n    const T &amp; initial_value,\n    const IndexArray &amp; dimensions\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-vectorn-24","title":"function VectorN [2/4]","text":"<pre><code>inline cip::VectorN::VectorN (\n    const VectorN &amp; other\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-vectorn-34","title":"function VectorN [3/4]","text":"<pre><code>template&lt;typename NestedVector&gt;\ninline cip::VectorN::VectorN (\n    const NestedVector &amp; nested\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-vectorn-44","title":"function VectorN [4/4]","text":"<pre><code>inline cip::VectorN::VectorN (\n    const IndexArray &amp; dimensions\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-data","title":"function data","text":"<pre><code>inline const std::vector&lt; T &gt; &amp; cip::VectorN::data () const\n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-dimensions","title":"function dimensions","text":"<pre><code>inline const IndexArray &amp; cip::VectorN::dimensions () const\n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-emplace_back","title":"function emplace_back","text":"<pre><code>template&lt;typename... Args&gt;\ninline void cip::VectorN::emplace_back (\n    Args... args\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-get_mdspan-12","title":"function get_mdspan [1/2]","text":"<pre><code>inline Mdspan cip::VectorN::get_mdspan () \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-get_mdspan-22","title":"function get_mdspan [2/2]","text":"<pre><code>inline const Mdspan cip::VectorN::get_mdspan () const\n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-move_into_submdspan-12","title":"function move_into_submdspan [1/2]","text":"<pre><code>template&lt;typename... SliceSpecs&gt;\ninline void cip::VectorN::move_into_submdspan (\n    std::vector&lt; T &gt; &amp;&amp; source,\n    SliceSpecs &amp;&amp;... specs\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-move_into_submdspan-22","title":"function move_into_submdspan [2/2]","text":"<pre><code>template&lt;std::size_t M, typename... SliceSpecs&gt;\ninline void cip::VectorN::move_into_submdspan (\n    VectorN &lt; T, M &gt; &amp;&amp; source,\n    SliceSpecs &amp;&amp;... specs\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-operator-14","title":"function operator() [1/4]","text":"<pre><code>template&lt;typename... Indices&gt;\ninline T &amp; cip::VectorN::operator() (\n    Indices... indices\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-operator-24","title":"function operator() [2/4]","text":"<pre><code>template&lt;typename... Indices&gt;\ninline const T &amp; cip::VectorN::operator() (\n    Indices... indices\n) const\n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-operator-34","title":"function operator() [3/4]","text":"<pre><code>inline T &amp; cip::VectorN::operator() (\n    IndexArray &amp; indices\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-operator-44","title":"function operator() [4/4]","text":"<pre><code>template&lt;typename... Indices&gt;\ninline const T &amp; cip::VectorN::operator() (\n    IndexArray &amp; indices\n) const\n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-submdspan-12","title":"function submdspan [1/2]","text":"<pre><code>template&lt;typename... Pairs&gt;\ninline Mdspan cip::VectorN::submdspan (\n    Pairs &amp;&amp;... pairs\n) const\n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-submdspan-22","title":"function submdspan [2/2]","text":"<pre><code>template&lt;typename... Pairs&gt;\ninline Mdspan cip::VectorN::submdspan (\n    Pairs &amp;&amp;... pairs\n) \n</code></pre>"},{"location":"reference/classcip_1_1VectorN/#function-submdspan_1d","title":"function submdspan_1d","text":"<pre><code>template&lt;typename... SliceArgs&gt;\ninline Mdspan1D cip::VectorN::submdspan_1d (\n    SliceArgs &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/vectorn.hpp</code></p>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition/","title":"Struct cip::setNaturalSplineBoundaryCondition","text":"<p>template &lt;BoundaryConditionType BC, typename T, typename Tx, typename Tf&gt;</p> <p>ClassList &gt; cip &gt; setNaturalSplineBoundaryCondition</p> <p>The documentation for this class was generated from the following file <code>include/slopes.hpp</code></p>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Clamped_00_01T_00_01Tx_00_01Tf_01_4/","title":"Struct cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;","text":"<p>template &lt;typename T, typename Tx, typename Tf&gt;</p> <p>ClassList &gt; cip &gt; setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;</p>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Clamped_00_01T_00_01Tx_00_01Tf_01_4/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; T &gt; Vector"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Clamped_00_01T_00_01Tx_00_01Tf_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr void operator() (const Tx &amp; x, const Tf &amp; f, Vector &amp; a, Vector &amp; b, Vector &amp; c, Vector &amp; d) const"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Clamped_00_01T_00_01Tx_00_01Tf_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Clamped_00_01T_00_01Tx_00_01Tf_01_4/#typedef-vector","title":"typedef Vector","text":"<pre><code>using cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;::Vector =  std::vector&lt;T&gt;;\n</code></pre>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Clamped_00_01T_00_01Tx_00_01Tf_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Clamped_00_01T_00_01Tx_00_01Tf_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr void cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;::operator() (\n    const Tx &amp; x,\n    const Tf &amp; f,\n    Vector &amp; a,\n    Vector &amp; b,\n    Vector &amp; c,\n    Vector &amp; d\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/slopes.hpp</code></p>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Natural_00_01T_00_01Tx_00_01Tf_01_4/","title":"Struct cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;","text":"<p>template &lt;typename T, typename Tx, typename Tf&gt;</p> <p>ClassList &gt; cip &gt; setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;</p>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Natural_00_01T_00_01Tx_00_01Tf_01_4/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; T &gt; Vector"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Natural_00_01T_00_01Tx_00_01Tf_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr void operator() (const Tx &amp; x, const Tf &amp; f, Vector &amp; a, Vector &amp; b, Vector &amp; c, Vector &amp; d) const"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Natural_00_01T_00_01Tx_00_01Tf_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Natural_00_01T_00_01Tx_00_01Tf_01_4/#typedef-vector","title":"typedef Vector","text":"<pre><code>using cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;::Vector =  std::vector&lt;T&gt;;\n</code></pre>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Natural_00_01T_00_01Tx_00_01Tf_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1Natural_00_01T_00_01Tx_00_01Tf_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr void cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;::operator() (\n    const Tx &amp; x,\n    const Tf &amp; f,\n    Vector &amp; a,\n    Vector &amp; b,\n    Vector &amp; c,\n    Vector &amp; d\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/slopes.hpp</code></p>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1NotAKnot_00_01T_00_01Tx_00_01Tf_01_4/","title":"Struct cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;","text":"<p>template &lt;typename T, typename Tx, typename Tf&gt;</p> <p>ClassList &gt; cip &gt; setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;</p>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1NotAKnot_00_01T_00_01Tx_00_01Tf_01_4/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; T &gt; Vector"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1NotAKnot_00_01T_00_01Tx_00_01Tf_01_4/#public-functions","title":"Public Functions","text":"Type Name constexpr void operator() (const Tx &amp; x, const Tf &amp; f, Vector &amp; a, Vector &amp; b, Vector &amp; c, Vector &amp; d) const"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1NotAKnot_00_01T_00_01Tx_00_01Tf_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1NotAKnot_00_01T_00_01Tx_00_01Tf_01_4/#typedef-vector","title":"typedef Vector","text":"<pre><code>using cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;::Vector =  std::vector&lt;T&gt;;\n</code></pre>"},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1NotAKnot_00_01T_00_01Tx_00_01Tf_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/structcip_1_1setNaturalSplineBoundaryCondition_3_01BoundaryConditionType_1_1NotAKnot_00_01T_00_01Tx_00_01Tf_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr void cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;::operator() (\n    const Tx &amp; x,\n    const Tf &amp; f,\n    Vector &amp; a,\n    Vector &amp; b,\n    Vector &amp; c,\n    Vector &amp; d\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/slopes.hpp</code></p>"},{"location":"reference/structcip_1_1VectorN_1_1Flatten/","title":"Struct cip::VectorN::Flatten","text":"<p>template &lt;typename NestedVector, std::size_t Rank&gt;</p> <p>ClassList &gt; Flatten</p>"},{"location":"reference/structcip_1_1VectorN_1_1Flatten/#public-static-functions","title":"Public Static Functions","text":"Type Name void apply (const NestedVector &amp; nested, std::vector&lt; T &gt; &amp; flat)"},{"location":"reference/structcip_1_1VectorN_1_1Flatten/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"reference/structcip_1_1VectorN_1_1Flatten/#function-apply","title":"function apply","text":"<pre><code>static inline void Flatten::apply (\n    const NestedVector &amp; nested,\n    std::vector&lt; T &gt; &amp; flat\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/vectorn.hpp</code></p>"},{"location":"reference/structcip_1_1VectorN_1_1Flatten_3_01NestedVector_00_011_01_4/","title":"Struct cip::VectorN::Flatten&lt; NestedVector, 1 &gt;","text":"<p>template &lt;typename NestedVector&gt;</p> <p>ClassList &gt; Flatten&lt; NestedVector, 1 &gt;</p>"},{"location":"reference/structcip_1_1VectorN_1_1Flatten_3_01NestedVector_00_011_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name void apply (const NestedVector &amp; nested, std::vector&lt; T &gt; &amp; flat)"},{"location":"reference/structcip_1_1VectorN_1_1Flatten_3_01NestedVector_00_011_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"reference/structcip_1_1VectorN_1_1Flatten_3_01NestedVector_00_011_01_4/#function-apply","title":"function apply","text":"<pre><code>static inline void Flatten&lt; NestedVector, 1 &gt;::apply (\n    const NestedVector &amp; nested,\n    std::vector&lt; T &gt; &amp; flat\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/vectorn.hpp</code></p>"},{"location":"reference/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir include","text":"<p>FileList &gt; include</p>"},{"location":"reference/dir_d44c64559bbebec7f509842c48db8b23/#files","title":"Files","text":"Type Name file cubic_spline.hpp file cubic_splines_1d.hpp file cubic_splines_2d.hpp file cubic_splines_3d.hpp file cubinterpp.hpp file derivatives.hpp file linear_interp.hpp file slopes.hpp file utils.hpp file vectorn.hpp <p>The documentation for this class was generated from the following file <code>include/</code></p>"},{"location":"reference/cubic__spline_8hpp/","title":"File cubic_spline.hpp","text":"<p>FileList &gt; include &gt; cubic_spline.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;mdspan/mdspan.hpp&gt;</code></li> <li><code>#include \"utils.hpp\"</code></li> <li><code>#include \"vectorn.hpp\"</code></li> <li><code>#include \"derivatives.hpp\"</code></li> </ul>"},{"location":"reference/cubic__spline_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/cubic__spline_8hpp/#classes","title":"Classes","text":"Type Name class CubicCellND &lt;typename T, N&gt; class CubicCellND&lt; T, 1 &gt; &lt;typename T&gt; class CubicInterpND &lt;typename T, N&gt; class CubicInterpND&lt; T, 1 &gt; &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>include/cubic_spline.hpp</code></p>"},{"location":"reference/cubic__spline_8hpp_source/","title":"File cubic_spline.hpp","text":"<p>File List &gt; include &gt; cubic_spline.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;cstddef&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n#include &lt;mdspan/mdspan.hpp&gt;\n#include \"utils.hpp\"\n#include \"vectorn.hpp\"\n#include \"derivatives.hpp\"\n\n\nnamespace cip {\n\n\ntemplate&lt;typename T, std::size_t N&gt;\nclass CubicCellND\n{\n    static constexpr std::size_t order = 4;\n    static constexpr std::size_t numCorners = 1 &lt;&lt; N;\n    static constexpr std::size_t numCoeffs = 1 &lt;&lt; (2 * N);\n    using CoeffsArray = std::array&lt;T, numCoeffs&gt;;\n    using Array = std::array&lt;T, order&gt;;\n    using Array2 = std::array&lt;Array, order&gt;;\n    using ArrayN = std::array&lt;T, N&gt;;\n    using Delta = std::array&lt;Array2, N&gt;;\n    using Span = std::span&lt;const T&gt;;\n    using Spans = std::array&lt;Span, N&gt;;\n    using Mdspan = std::mdspan&lt;const T, std::dextents&lt;std::size_t, 2*N&gt;, std::layout_stride&gt;;\npublic:\n\n    explicit CubicCellND(const Mdspan &amp;F, const Spans &amp;x)\n      : coeffs(calc_coeffs(x, F))\n    {\n    }\n    ~CubicCellND() = default;\n\n    template &lt;typename... Args&gt;\n    requires (sizeof...(Args) == N)\n    T eval(Args&amp;&amp;... xi) const\n    {\n        return eval_poly&lt;0&gt;(0, {std::forward&lt;Args&gt;(xi)...});\n    }\n\nprivate:\n    const CoeffsArray coeffs;\n\n    const ArrayN calc_h(const Spans &amp;x) const\n    {\n        return std::apply(\n            [](const auto&amp;... xi) { return ArrayN{(xi[1] - xi[0])...}; },\n            x\n        );\n    }\n\n    const T calc_h3(const ArrayN &amp;h) const\n    {\n        T prod_hi = std::apply(\n            [](const auto&amp;... hi) { return (hi * ...); },\n            h\n        );\n        return prod_hi*prod_hi*prod_hi;\n    }\n\n    const Array2 calc_delta_ij(const Span &amp;xi) const \n    {\n        const T x0 = xi[0];\n        const T x1 = xi[1];\n        const T x02 = x0*x0;\n        const T x12 = x1*x1;\n        return {{{x12*(x1 - 3.0*x0), +6.0*x0*x1,           -3.0*(x0 + x1), +2.0},\n                 {-x0*x12,           x1*(2.0*x0 + x1),     -(x0 + 2.0*x1), +1.0},\n                 {x02*(3.0*x1 - x0), -6.0*x0*x1,           +3.0*(x0 + x1), -2.0},\n                 {-x1*x02,           x0*(x0 + 2.0*x1),     -(2.0*x0 + x1), +1.0}}};\n    }\n\n    const Delta calc_delta(const Spans &amp;x) const \n    {\n        return std::apply(\n            [this](const auto&amp;... xi) { return Delta{calc_delta_ij(xi)...}; },\n            x\n        );\n    }\n\n    const CoeffsArray calc_coeffs(const Spans &amp;x, const Mdspan &amp;F) const {\n        const ArrayN h = calc_h(x);\n        const T h3 = calc_h3(h);\n        const Delta delta = calc_delta(x);\n        CoeffsArray _coeffs = {};\n        std::array&lt;std::size_t, 2*N&gt; indices = {};\n        for (std::size_t m_idx = 0; m_idx &lt; numCoeffs; ++m_idx) {\n            for (std::size_t i = 0; i &lt; numCorners; ++i) {\n                for (std::size_t j = 0; j &lt; numCorners; ++j) {\n                    T product = T{1.0};\n                    for (std::size_t k = 0; k &lt; N; ++k) {\n                        std::size_t i_k = (i &gt;&gt; k) &amp; 1;\n                        std::size_t j_k = (j &gt;&gt; k) &amp; 1;\n                        std::size_t ij_k = (i_k &lt;&lt; 1) | j_k;\n                        std::size_t m_k = (m_idx &gt;&gt; ((N-1-k)*2)) &amp; 3;\n                        indices[k]   = i_k;\n                        indices[k+N] = j_k;\n                        T h_factor = (j_k == 0) ? 1.0 : h[k];\n                        product *= h_factor * delta[k][ij_k][m_k];\n                    }\n                    _coeffs[m_idx] += F(indices)*product;\n                }\n            }\n            _coeffs[m_idx] /= h3;\n        }\n        return _coeffs;\n    }\n\n    template &lt;std::size_t D&gt;\n    constexpr T eval_poly(std::size_t offset, const std::array&lt;T, N&gt;&amp; x) const\n    {\n        if constexpr (D == N)\n        {\n            return coeffs[offset];\n        } else {\n            constexpr std::size_t stride = cip::power&lt;order, N-D-1&gt;();\n            T c0 = eval_poly&lt;D+1&gt;(offset, x);\n            T c1 = eval_poly&lt;D+1&gt;(offset + stride, x);\n            T c2 = eval_poly&lt;D+1&gt;(offset + 2*stride, x);\n            T c3 = eval_poly&lt;D+1&gt;(offset + 3*stride, x);\n            return c0 + x[D]*(c1 + x[D]*(c2 + x[D]*c3));\n        }\n    }\n\n};\n\n\n\ntemplate &lt;typename T, std::size_t N&gt;\nclass CubicInterpND\n{\n    static constexpr std::size_t size_t_two = 2;\n    using Vector = std::vector&lt;T&gt;;\n    using Array = std::array&lt;Vector, N&gt;;\n    using Cell = CubicCellND&lt;T, N&gt;;\n    using Cells = cip::VectorN&lt;Cell, N&gt;;\n    using Span = std::span&lt;const T&gt;;\n    using Mdspan = std::mdspan&lt;T, std::dextents&lt;std::size_t, N&gt;, std::layout_stride&gt;;\n    using Mdspan1D = std::mdspan&lt;T, std::dextents&lt;std::size_t, 1&gt;, std::layout_stride&gt;;\n    using Ff = cip::VectorN&lt;T, N&gt;;\n    using Ff2 = cip::VectorN&lt;T, 2*N&gt;;\n    using Pr = std::pair&lt;std::size_t, std::size_t&gt;;\n    using Indexers = std::array&lt;cip::Indexer&lt;T&gt;, N&gt;;\npublic:\n    template &lt;typename... Args&gt;    \n    CubicInterpND(const Ff &amp;_f, const Args &amp; ... _xi)\n      : xi{_xi...},\n        indexers{cip::Indexer&lt;T&gt;(_xi)...},\n        F(T{}, {_xi.size()..., ((void)_xi, size_t_two)...}),\n        cells({(_xi.size()-1)...})\n    {\n    }\n    virtual ~CubicInterpND() { }\n\n    virtual Vector calc_slopes(const Vector &amp;x, const Mdspan1D &amp;f) const = 0;\n\n    template &lt;typename... Args&gt;\n    void build(const Ff &amp;f, const Args &amp; ... _xi)\n    {\n        populate_F(f, _xi...);\n        build_cell(cells);\n    }\n\n    template &lt;typename... Args&gt;\n    T eval(const Args&amp;... args) const\n    {\n        std::size_t dim = 0;\n        std::array&lt;size_t, N&gt; indices = { indexers[dim++].sort_index(args)... };\n        return cells(indices).eval(args...);\n    }\n\n\nprivate:\n    const Array xi;\n    const Vector x;\n    const Vector y;\n    const Indexers indexers;\n    Cells cells;\n    Ff2 F;\n\n    template &lt;typename... Args&gt;\n    void populate_F(Ff f, const Args &amp; ... _xi) { // NOTE: pass f by value, which will be moved into F\n        F.move_into_submdspan(std::move(f), ((void)_xi, std::full_extent)..., ((void)_xi, 0)...);\n        auto slopesLambda = [this](const Vector &amp;x, const Mdspan1D &amp;f_slice) -&gt; Vector {\n            return this-&gt;calc_slopes(x, f_slice);\n        };\n        cip::compute_mixed_derivatives&lt;N&gt;(F, xi, slopesLambda);\n    }\n\n    template &lt;typename... Indices&gt;\n    void build_cell(Cells &amp;_cells, Indices... indices) const {\n        if constexpr (sizeof...(Indices) == N) {\n            std::size_t index = 0;\n            std::array&lt;Span, N&gt; spans = { Span(&amp;xi[index++][indices], 2)... };\n            _cells.emplace_back(\n                F.submdspan(Pr{indices, indices+1}..., ((void)indices, std::full_extent)...),\n                spans\n            );\n        } else {\n            for (std::size_t i = 0; i &lt; xi[sizeof...(indices)].size() - 1; ++i) {\n                build_cell(_cells, indices..., i);\n            }\n        }\n    }\n\n};\n\n\ntemplate&lt;typename T&gt;\nclass CubicCellND&lt;T, 1&gt;\n{\n    static constexpr std::size_t order = 4;\n    using Array = std::array&lt;T, order&gt;;\n    using Alpha = std::array&lt;Array, order&gt;;\n    using Span = std::span&lt;const T&gt;;\n    using Mdspan = std::mdspan&lt;const T, std::dextents&lt;std::size_t, 2&gt;, std::layout_stride&gt;;\npublic:\n    explicit CubicCellND(const Span &amp;x, const Mdspan &amp;F)\n      : coeffs(calc_coeffs(x, F))\n    {\n    }\n    ~CubicCellND() = default;\n\n    const T eval(const T x) const\n    {\n        return coeffs[0] + (coeffs[1] + (coeffs[2] + coeffs[3]*x)*x)*x;\n    }\n\nprivate:\n    const Array coeffs;\n\n    constexpr Array calc_coeffs(const Span &amp;x, const Mdspan &amp;F) noexcept {\n        const T x0 = x[0];\n        const T x1 = x[1];\n        const T h  = x1 - x0;\n        const T h3 = h*h*h;\n        const T x02 = x0*x0;\n        const T x12 = x1*x1;\n        const T f0 = F(0,0);\n        const T f1 = F(1,0);\n        const T df0 = F(0,1);\n        const T df1 = F(1,1);\n        const T diff = f0 - f1;\n        return {\n            (f0*x12*(x1 - 3.0*x0) + f1*x02*(3.0*x1 - x0) - h*x0*x1*(df0*x1 + df1* x0))/h3,\n            (+6.0*x0*x1*diff + h*( df0*x1*(2.0*x0 + x1) + df1*x0*(x0 + 2.0*x1)))/h3,\n            (-3.0*(x0 + x1)*diff - h*( df0*(x0 + 2.0*x1) + df1*(2.0*x0 + x1)))/h3,\n            (+2.0*diff + h*(df0 + df1))/h3\n        };\n    }\n\n};\n\n\ntemplate &lt;typename T&gt;\nclass CubicInterpND&lt;T, 1&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\n    using Cell = CubicCellND&lt;T, 1&gt;;\n    using Cells = std::vector&lt;Cell&gt;;\n    using Span = std::span&lt;const T&gt;;\n    using VectorN2 = cip::VectorN&lt;T, 2&gt;;\n    using Pr = std::pair&lt;std::size_t, std::size_t&gt;;\npublic:\n    CubicInterpND(const Vector &amp;_x, const Vector &amp;_f)\n      : x(_x),\n        indexer(_x),\n        F(T{}, {x.size(), 2})\n    {\n        assert(x.size() == _f.size());\n    }\n    virtual ~CubicInterpND() { }\n\n    virtual Vector calc_slopes(const Vector &amp;x, const Vector &amp;f) const = 0;\n\n    void build(Vector f) // don't pass by reference but by value (to create a copy)!\n    {\n        const std::size_t n = x.size() - 1;\n        F.move_into_submdspan(std::move(f), std::full_extent, 0);\n        F.move_into_submdspan(calc_slopes(x, f), std::full_extent, 1);\n        cells.reserve(n);\n        for (auto i = 0; i &lt; n; ++i)\n        {\n            cells.emplace_back(Span(&amp;x[i], 2), F.submdspan(Pr{i, i+1}, std::full_extent));\n        }\n    }\n\n    T eval(const T xi) const\n    {\n        return cells[indexer.sort_index(xi)].eval(xi);\n    };\n\n    Vector evaln(const Vector &amp;xi) const\n    {\n        auto xi_iter = xi.begin();\n        Vector yi(xi.size());\n        for (auto &amp;yi_i : yi)\n        {\n            yi_i = eval(*xi_iter++);\n        }\n        return yi;\n    }\n\nprivate:\n    const Vector x;\n    const cip::Indexer&lt;T&gt; indexer;\n    Cells cells;\n    VectorN2 F;\n\n};\n\n\n} // namespace cip\n</code></pre>"},{"location":"reference/cubic__splines__1d_8hpp/","title":"File cubic_splines_1d.hpp","text":"<p>FileList &gt; include &gt; cubic_splines_1d.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cubic_spline.hpp\"</code></li> <li><code>#include \"slopes.hpp\"</code></li> <li><code>#include &lt;cstddef&gt;</code></li> </ul>"},{"location":"reference/cubic__splines__1d_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/cubic__splines__1d_8hpp/#classes","title":"Classes","text":"Type Name class AkimaSpline1D &lt;typename T, N&gt; class MonotonicSpline1D &lt;typename T, N&gt; class NaturalSpline1D &lt;typename T, N, BC&gt; <p>The documentation for this class was generated from the following file <code>include/cubic_splines_1d.hpp</code></p>"},{"location":"reference/cubic__splines__1d_8hpp_source/","title":"File cubic_splines_1d.hpp","text":"<p>File List &gt; include &gt; cubic_splines_1d.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"cubic_spline.hpp\"\n#include \"slopes.hpp\"\n#include &lt;cstddef&gt;\n\n\nnamespace cip {\n\n\ntemplate &lt;typename T, std::size_t N=1&gt;\nclass MonotonicSpline1D : public CubicInterpND&lt;T, N&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\npublic:\n    MonotonicSpline1D(const Vector &amp;x, const Vector &amp;f)\n    : CubicInterpND&lt;T, N&gt;(x, f)\n    {\n        this-&gt;build(f);\n    }\n\n    ~MonotonicSpline1D() {}\n\n    Vector calc_slopes(const Vector &amp;x, const Vector &amp;f) const override {\n        return monotonic_slopes&lt;T&gt;(x, f);\n    }\n\n};\n\n\ntemplate &lt;typename T, std::size_t N=1&gt;\nclass AkimaSpline1D : public CubicInterpND&lt;T, N&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\npublic:\n    AkimaSpline1D(const Vector &amp;x, const Vector &amp;f)\n    : CubicInterpND&lt;T, N&gt;(x, f)\n    {\n        this-&gt;build(f);\n    }\n\n    ~AkimaSpline1D() {}\n\n    Vector calc_slopes(const Vector &amp;x, const Vector &amp;f) const override {\n        return akima_slopes&lt;T&gt;(x, f);\n    }\n\n};\n\n\ntemplate &lt;typename T, std::size_t N=1, cip::BoundaryConditionType BC=cip::BoundaryConditionType::Natural&gt;\nclass NaturalSpline1D : public CubicInterpND&lt;T, N&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\npublic:\n    NaturalSpline1D(const Vector &amp;x, const Vector &amp;f)\n    : CubicInterpND&lt;T, N&gt;(x, f)\n    {\n        this-&gt;build(f);\n    }\n\n    ~NaturalSpline1D() {}\n\n    Vector calc_slopes(const Vector &amp;x, const Vector &amp;f) const override {\n        return natural_spline_slopes&lt;T, BC&gt;(x, f);\n    }\n\n};\n\n\n} // namespace cip\n</code></pre>"},{"location":"reference/cubic__splines__2d_8hpp/","title":"File cubic_splines_2d.hpp","text":"<p>FileList &gt; include &gt; cubic_splines_2d.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cubic_spline.hpp\"</code></li> <li><code>#include \"slopes.hpp\"</code></li> </ul>"},{"location":"reference/cubic__splines__2d_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/cubic__splines__2d_8hpp/#classes","title":"Classes","text":"Type Name class AkimaSpline2D &lt;typename T, N&gt; class MonotonicSpline2D &lt;typename T, N&gt; class NaturalSpline2D &lt;typename T, BC, N&gt; <p>The documentation for this class was generated from the following file <code>include/cubic_splines_2d.hpp</code></p>"},{"location":"reference/cubic__splines__2d_8hpp_source/","title":"File cubic_splines_2d.hpp","text":"<p>File List &gt; include &gt; cubic_splines_2d.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"cubic_spline.hpp\"\n#include \"slopes.hpp\"\n\n\nnamespace cip {\n\n\ntemplate &lt;typename T, std::size_t N=2&gt;\nclass MonotonicSpline2D : public CubicInterpND&lt;T, N&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\n    using Mdspan1D = std::mdspan&lt;T, std::dextents&lt;std::size_t, 1&gt;, std::layout_stride&gt;;\n    using VectorN = cip::VectorN&lt;T, N&gt;;\npublic:\nMonotonicSpline2D(const Vector &amp;_x, const Vector &amp;_y, const VectorN &amp;_f)\n    : CubicInterpND&lt;T, N&gt;(_f, _x, _y)\n    {\n        this-&gt;build(_f, _x, _y);\n    }\n    ~MonotonicSpline2D() {}\n\n    Vector calc_slopes(const Vector &amp;x, const Mdspan1D &amp;f) const override\n    {\n        return monotonic_slopes&lt;T&gt;(x, f);\n    }\n};\n\n\ntemplate &lt;typename T, std::size_t N=2&gt;\nclass AkimaSpline2D : public CubicInterpND&lt;T, N&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\n    using Mdspan1D = std::mdspan&lt;T, std::dextents&lt;std::size_t, 1&gt;, std::layout_stride&gt;;\n    using VectorN = cip::VectorN&lt;T, N&gt;;\npublic:\n    AkimaSpline2D(const Vector &amp;_x, const Vector &amp;_y, const VectorN &amp;_f)\n    : CubicInterpND&lt;T, N&gt;(_f, _x, _y)\n    {\n        this-&gt;build(_f, _x, _y);\n    }\n    ~AkimaSpline2D() {}\n\n    Vector calc_slopes(const Vector &amp;x, const Mdspan1D &amp;f) const override\n    {\n        return akima_slopes&lt;T&gt;(x, f);\n    }\n};\n\n\n\ntemplate &lt;typename T, cip::BoundaryConditionType BC=cip::BoundaryConditionType::NotAKnot, std::size_t N=2&gt;\nclass NaturalSpline2D : public CubicInterpND&lt;T, N&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\n    using Mdspan1D = std::mdspan&lt;T, std::dextents&lt;std::size_t, 1&gt;, std::layout_stride&gt;;\n    using VectorN = cip::VectorN&lt;T, N&gt;;\npublic:\n    NaturalSpline2D(const Vector &amp;_x, const Vector &amp;_y, const VectorN &amp;_f)\n    : CubicInterpND&lt;T, N&gt;(_f, _x, _y)\n    {\n        this-&gt;build(_f, _x, _y);\n    }\n    ~NaturalSpline2D() {}\n\n    Vector calc_slopes(const Vector &amp;x, const Mdspan1D &amp;f) const override\n    {\n        return natural_spline_slopes&lt;T, BC&gt;(x, f);\n    }\n};\n\n\n} // namespace cip\n</code></pre>"},{"location":"reference/cubic__splines__3d_8hpp/","title":"File cubic_splines_3d.hpp","text":"<p>FileList &gt; include &gt; cubic_splines_3d.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cubic_spline.hpp\"</code></li> <li><code>#include \"slopes.hpp\"</code></li> </ul>"},{"location":"reference/cubic__splines__3d_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/cubic__splines__3d_8hpp/#classes","title":"Classes","text":"Type Name class NaturalSpline3D &lt;typename T, BC, N&gt; <p>The documentation for this class was generated from the following file <code>include/cubic_splines_3d.hpp</code></p>"},{"location":"reference/cubic__splines__3d_8hpp_source/","title":"File cubic_splines_3d.hpp","text":"<p>File List &gt; include &gt; cubic_splines_3d.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"cubic_spline.hpp\"\n#include \"slopes.hpp\"\n\n\nnamespace cip {\n\n\ntemplate &lt;typename T, cip::BoundaryConditionType BC=cip::BoundaryConditionType::NotAKnot, std::size_t N=3&gt;\nclass NaturalSpline3D : public CubicInterpND&lt;T, N&gt;\n{\n    using Vector = std::vector&lt;T&gt;;\n    using Mdspan1D = std::mdspan&lt;T, std::dextents&lt;std::size_t, 1&gt;, std::layout_stride&gt;;\n    using VectorN = cip::VectorN&lt;T, N&gt;;\npublic:\n    NaturalSpline3D(const Vector &amp;_x, const Vector &amp;_y, const Vector &amp;_z, const VectorN &amp;_f)\n    : CubicInterpND&lt;T, N&gt;(_f, _x, _y, _z)\n    {\n        this-&gt;build(_f, _x, _y, _z);\n    }\n    ~NaturalSpline3D() {}\n\n    Vector calc_slopes(const Vector &amp;x, const Mdspan1D &amp;f) const override\n    {\n        return natural_spline_slopes&lt;T, BC&gt;(x, f);\n    }\n};\n\n\n} // namespace cip\n</code></pre>"},{"location":"reference/cubinterpp_8hpp/","title":"File cubinterpp.hpp","text":"<p>FileList &gt; include &gt; cubinterpp.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"utils.hpp\"</code></li> <li><code>#include \"slopes.hpp\"</code></li> <li><code>#include \"vectorn.hpp\"</code></li> <li><code>#include \"derivatives.hpp\"</code></li> <li><code>#include \"linear_interp.hpp\"</code></li> <li><code>#include \"cubic_spline.hpp\"</code></li> <li><code>#include \"cubic_splines_1d.hpp\"</code></li> <li><code>#include \"cubic_splines_2d.hpp\"</code></li> <li><code>#include \"cubic_splines_3d.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>include/cubinterpp.hpp</code></p>"},{"location":"reference/cubinterpp_8hpp_source/","title":"File cubinterpp.hpp","text":"<p>File List &gt; include &gt; cubinterpp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"utils.hpp\"\n#include \"slopes.hpp\"\n#include \"vectorn.hpp\"\n#include \"derivatives.hpp\"\n#include \"linear_interp.hpp\"\n#include \"cubic_spline.hpp\"\n#include \"cubic_splines_1d.hpp\"\n#include \"cubic_splines_2d.hpp\"\n#include \"cubic_splines_3d.hpp\"\n</code></pre>"},{"location":"reference/derivatives_8hpp/","title":"File derivatives.hpp","text":"<p>FileList &gt; include &gt; derivatives.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;mdspan/mdspan.hpp&gt;</code></li> </ul>"},{"location":"reference/derivatives_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip <p>The documentation for this class was generated from the following file <code>include/derivatives.hpp</code></p>"},{"location":"reference/derivatives_8hpp_source/","title":"File derivatives.hpp","text":"<p>File List &gt; include &gt; derivatives.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\n#include &lt;mdspan/mdspan.hpp&gt;\n\n\nnamespace cip {\n\n\ntemplate &lt;std::size_t N, std::size_t D, std::size_t current = 0, typename Func, typename XiArray, typename... Indices&gt;\nvoid iterate_over_indices(Func&amp;&amp; func, XiArray const&amp; xi, Indices... indices) {\n    if constexpr (current == N) {\n        func(indices...);\n    } else {\n        if constexpr (current == D) {\n            iterate_over_indices&lt;N, D, current + 1&gt;(std::forward&lt;Func&gt;(func), xi, indices...);\n        } else {\n            for (std::size_t i = 0; i &lt; xi[current].size(); ++i)\n            {\n                iterate_over_indices&lt;N, D, current + 1&gt;(std::forward&lt;Func&gt;(func), xi, indices..., i);\n            }\n        }\n    }\n}\n\ntemplate &lt;std::size_t I, std::size_t N, std::size_t D, typename Tuple, typename Accum&gt;\nconstexpr auto build_coordinate_indices_impl(const Tuple&amp; t, Accum acc) {\n    if constexpr (I == N) {\n        return acc;\n    } else {\n        if constexpr (I == D) {\n            return build_coordinate_indices_impl&lt;I + 1, N, D&gt;(\n                t, std::tuple_cat(acc, std::make_tuple(std::full_extent))\n            );\n        } else if constexpr (I &lt; D) {\n            return build_coordinate_indices_impl&lt;I + 1, N, D&gt;(\n                t, std::tuple_cat(acc, std::make_tuple(std::get&lt;I&gt;(t)))\n            );\n        } else {\n            return build_coordinate_indices_impl&lt;I + 1, N, D&gt;(\n                t, std::tuple_cat(acc, std::make_tuple(std::get&lt;I - 1&gt;(t)))\n            );\n        }\n    }\n}\n\ntemplate &lt;std::size_t N, std::size_t D, typename Tuple&gt;\nconstexpr auto build_coordinate_indices(const Tuple&amp; t) {\n    return build_coordinate_indices_impl&lt;0, N, D&gt;(t, std::tuple&lt;&gt;());\n}\n\ntemplate &lt;typename FType, typename CoordTuple, typename DerivTuple&gt;\nauto call_submdspan_1d(FType&amp; F, const CoordTuple&amp; coord, const DerivTuple&amp; deriv) {\n    return std::apply([&amp;F](const auto&amp;... args) {\n        return F.submdspan_1d(args...);\n    }, std::tuple_cat(coord, deriv));\n}\n\ntemplate &lt;typename FType, typename SlopeType, typename CoordTuple, typename DerivTuple&gt;\nvoid call_move_into_submdspan(FType&amp; F, SlopeType&amp;&amp; slopes, const CoordTuple&amp; coord, const DerivTuple&amp; deriv) {\n    std::apply([&amp;F, &amp;slopes](const auto&amp;... args) {\n        F.move_into_submdspan(std::forward&lt;SlopeType&gt;(slopes),args...);\n    }, std::tuple_cat(coord, deriv));\n}\n\nconstexpr std::size_t SIZE_T_ZERO = 0;\n\ntemplate &lt;std::size_t N&gt;\nconstexpr auto make_zero_tuple() {\n    return []&lt;std::size_t... I&gt;(std::index_sequence&lt;I...&gt;) {\n        return std::make_tuple(((void)I, SIZE_T_ZERO)...);\n    }(std::make_index_sequence&lt;N&gt;{});\n}\n\ntemplate &lt;std::size_t D, typename Tuple, typename T&gt;\nconstexpr auto update_tuple_element(const Tuple&amp; tup, T new_value) {\n    constexpr std::size_t N = std::tuple_size_v&lt;Tuple&gt;;\n    return []&lt;std::size_t... Is&gt;(const Tuple&amp; tup, T new_value, std::index_sequence&lt;Is...&gt;) {\n        return std::make_tuple((Is == D ? new_value : std::get&lt;Is&gt;(tup))...);\n    }(tup, new_value, std::make_index_sequence&lt;N&gt;{});\n}\n\ntemplate &lt;std::size_t N, typename Tuple, typename Func, std::size_t... Is&gt;\nconstexpr void for_each_dimension_impl(const Tuple&amp; tup, Func&amp;&amp; func, std::index_sequence&lt;Is...&gt;) {\n    ((std::get&lt;Is&gt;(tup) == 0 ? (func(std::integral_constant&lt;std::size_t, Is&gt;{}), 0) : 0), ...);\n}\n\ntemplate &lt;std::size_t N, typename Tuple, typename Func&gt;\nconstexpr void for_each_dimension(const Tuple&amp; tup, Func&amp;&amp; func) {\n    for_each_dimension_impl&lt;N&gt;(tup, std::forward&lt;Func&gt;(func), std::make_index_sequence&lt;N&gt;{});\n}\n\ntemplate &lt;std::size_t N, typename FType, typename XiArray, typename DerivTuple, typename CalcSlopesFunctor&gt;\nvoid compute_mixed_derivatives_impl(FType&amp; F, XiArray const&amp; xi, const DerivTuple&amp; currentDeriv, CalcSlopesFunctor calcSlopes, std::size_t start = 0) {\n    for_each_dimension&lt;N&gt;(currentDeriv, [&amp;](const auto d_const) {\n        constexpr std::size_t D = d_const.value;\n        if (D &lt; start) {\n            return;\n        }\n        iterate_over_indices&lt;N, D&gt;([&amp;, d_const](auto... loopIndices) {\n            constexpr std::size_t D = d_const.value;\n            auto indicesTuple = std::make_tuple(loopIndices...);\n            auto coord = build_coordinate_indices&lt;N, D&gt;(indicesTuple);\n            auto extractionPattern = update_tuple_element&lt;D&gt;(currentDeriv, 0);\n            auto f_slice = call_submdspan_1d(F, coord, extractionPattern);\n            auto newDeriv = update_tuple_element&lt;D&gt;(currentDeriv, 1);\n            call_move_into_submdspan(F, calcSlopes(xi[D], f_slice), coord, newDeriv);\n        }, xi);\n        auto newDeriv = update_tuple_element&lt;D&gt;(currentDeriv, 1);\n        compute_mixed_derivatives_impl&lt;N&gt;(F, xi, newDeriv, calcSlopes, D+1);\n    });\n}\n\ntemplate &lt;std::size_t N, typename FType, typename XiArray, typename CalcSlopesFunctor&gt;\nvoid compute_mixed_derivatives(FType&amp; F, XiArray const&amp; xi, CalcSlopesFunctor calcSlopes) {\n    auto basePattern = make_zero_tuple&lt;N&gt;();\n    compute_mixed_derivatives_impl&lt;N&gt;(F, xi, basePattern, calcSlopes, 0);\n}\n\n\n}  // namespace cip\n</code></pre>"},{"location":"reference/linear__interp_8hpp/","title":"File linear_interp.hpp","text":"<p>FileList &gt; include &gt; linear_interp.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;mdspan/mdspan.hpp&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include \"vectorn.hpp\"</code></li> <li><code>#include \"utils.hpp\"</code></li> </ul>"},{"location":"reference/linear__interp_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/linear__interp_8hpp/#classes","title":"Classes","text":"Type Name class LinearCellND &lt;typename T, N&gt; class LinearCellND&lt; T, 1 &gt; &lt;typename T&gt; class LinearInterp1D &lt;typename T&gt; class LinearInterp2D &lt;typename T&gt; class LinearInterp3D &lt;typename T&gt; class LinearInterp4D &lt;typename T&gt; class LinearInterpND &lt;typename T, N&gt; class LinearInterpND&lt; T, 1 &gt; &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>include/linear_interp.hpp</code></p>"},{"location":"reference/linear__interp_8hpp_source/","title":"File linear_interp.hpp","text":"<p>File List &gt; include &gt; linear_interp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;cstddef&gt;\n#include &lt;vector&gt;\n#include &lt;mdspan/mdspan.hpp&gt;\n#include &lt;utility&gt;\n#include &lt;numeric&gt;\n#include &lt;tuple&gt;\n#include \"vectorn.hpp\"\n#include \"utils.hpp\"\n\n\nnamespace cip {\n\n\ntemplate &lt;typename T, std::size_t N&gt;\nclass LinearCellND {\n    using Span = std::span&lt;const T&gt;;\n    using Spans = std::array&lt;Span, N&gt;;\n    using Mdspan = std::mdspan&lt;const T, std::dextents&lt;std::size_t, N&gt;, std::layout_stride&gt;;\n    using NomArray = std::array&lt;T, (1 &lt;&lt; N)&gt;;\n    static constexpr std::size_t numCorners = 1 &lt;&lt; N;\npublic:\n    explicit LinearCellND(const Mdspan &amp;_f, const Spans &amp;_x)\n    : x(_x),\n      f(_f),\n      H(std::transform_reduce(x.begin(), x.end(), T{1}, std::multiplies&lt;&gt;{},\n        [](const Span&amp; xi) { return xi[1] - xi[0]; })),\n      c(compute_coefficients())\n    {\n    }\n\n    template &lt;typename... Args&gt;\n    requires (sizeof...(Args) == N)\n    T eval(Args&amp;&amp;... args) const\n    {\n        return gather_corners(\n            {std::forward&lt;Args&gt;(args)...},\n            std::make_index_sequence&lt;numCorners&gt;{}\n        );\n    }\n\n\nprivate:\n    const Spans x;\n    const Mdspan f;\n    const T H;\n    const NomArray c;\n\n    NomArray compute_coefficients() const {\n        NomArray c;\n        for (std::size_t J = 0; J &lt; numCorners; ++J) {\n            c[J] = compute_c_J(J);\n        }\n        return c;\n    }\n\n    T compute_c_J(std::size_t J) const {\n        T c_J = T{0};\n        for (std::size_t mask = 0; mask &lt; numCorners; ++mask) {\n            T prod = T{1};\n            std::array&lt;std::size_t, N&gt; indices{};\n            for (std::size_t k = 0; k &lt; N; ++k) {\n                indices[k] = (mask &amp; (1u &lt;&lt; k)) ? 1 : 0;\n                prod *= gamma(J, indices[k], k);\n            }\n            c_J += f(indices) * prod;\n        }\n        return c_J / H;\n    }\n\n    T gamma(std::size_t J, std::size_t i, std::size_t k) const {\n        return (J &amp; (1u &lt;&lt; k))\n            ? (i == 0 ? -T{1} : T{1})\n            : (i == 0 ? x[k][1] : -x[k][0]);\n    }\n\n    template &lt;std::size_t... Js&gt;\n    T gather_corners(const std::array&lt;T, N&gt;&amp; xs, std::index_sequence&lt;Js...&gt;) const {\n        return ( ... + compute_corner&lt;Js&gt;(xs, std::make_index_sequence&lt;N&gt;{}) );\n    }\n\n    template &lt;std::size_t J, std::size_t... I&gt;\n    T compute_corner(const std::array&lt;T, N&gt;&amp; xs, std::index_sequence&lt;I...&gt;) const {\n        return c[J] * (T{1} * ... * ((J &amp; (1u &lt;&lt; I)) ? xs[I] : T{1}));\n    }\n\n}; // class LinearCellND\n\n\ntemplate &lt;typename T, std::size_t N&gt;\nclass LinearInterpND {\n    using Vector = std::vector&lt;T&gt;;\n    using Array = std::array&lt;Vector, N&gt;;\n    using F = cip::VectorN&lt;T, N&gt;;\n    using Cell = LinearCellND&lt;T, N&gt;;\n    using Cells = cip::VectorN&lt;Cell, N&gt;;\n    using Span = std::span&lt;const T&gt;;\n    using Pr = std::pair&lt;std::size_t, std::size_t&gt;;\n    using Indexers = std::array&lt;cip::Indexer&lt;T&gt;, N&gt;;\npublic:\n    template &lt;typename... Args&gt;\n    LinearInterpND(const F &amp;_f, const Args &amp; ... _xi)\n    : xi{_xi...}, \n      f(_f), \n      indexers{cip::Indexer&lt;T&gt;(_xi)...}, \n      cells(build(_xi...))\n    {\n    }\n\n    ~LinearInterpND() { }\n\n    template &lt;typename... Args&gt;\n    T eval(const Args&amp;... args) const\n    {\n        std::size_t dim = 0;\n        std::array&lt;size_t, N&gt; indices = { indexers[dim++].sort_index(args)... };\n        return cells(indices).eval(args...);\n    }\n\n    template &lt;typename... Vectors&gt;\n    Vector evaln(const Vectors &amp; ... inputs) const\n    {\n        static_assert(sizeof...(inputs) &gt; 0, \"At least one input vector is required\");\n\n        const std::size_t size = std::get&lt;0&gt;(std::tuple&lt;const Vectors&amp;...&gt;(inputs...)).size();\n        if (!((inputs.size() == size) &amp;&amp; ...)) {\n            throw std::invalid_argument(\"All input vectors must have the same size\");\n        }\n\n        Vector z(size); // Output vector\n        for (std::size_t i = 0; i &lt; size; ++i) {\n            z[i] = eval(inputs[i]...);\n        }\n        return z;\n    }\n\n\nprivate:\n    const Array xi;\n    const F f;\n    const Indexers indexers;\n    const Cells cells;\n\n    template &lt;typename... Args&gt;\n    const Cells build(const Args &amp; ... _xi) const\n    {\n        Cells _cells({(_xi.size()-1)...});\n        build_cell(_cells);\n        return _cells;\n    }\n\n    template &lt;typename... Indices&gt;\n    void build_cell(Cells &amp;_cells, Indices... indices) const {\n        if constexpr (sizeof...(Indices) == N) {\n            std::size_t index = 0;\n            std::array&lt;Span, N&gt; spans = {Span(&amp;xi[index++][indices], 2)...};\n            _cells.emplace_back(\n                f.submdspan(Pr{indices, indices+1}...),\n                spans\n            );\n        } else {\n            for (std::size_t i = 0; i &lt; xi[sizeof...(indices)].size()-1; ++i) {\n                build_cell(_cells, indices..., i);\n            }\n        }\n    }\n\n}; // class LinearInterpND\n\n\n\ntemplate &lt;typename T&gt;\nclass LinearCellND&lt;T, 1&gt; {\n    using Span = std::span&lt;const T&gt;;\npublic:\n    explicit LinearCellND(Span x, Span f)\n    : x0(x[0]),\n      b0((x[1]*f[0]-x[0]*f[1])/(x[1]-x[0])),\n      a0((f[1]-f[0])/(x[1]-x[0]))\n    {\n    }\n    ~LinearCellND() { }\n\n    T eval(const T &amp;xi) const\n    {\n        return b0 + a0*xi;\n    }\n\nprivate:\n    const T x0;\n    const T a0;\n    const T b0;\n};\n\n\ntemplate &lt;typename T&gt;\nclass LinearInterpND&lt;T, 1&gt; {\n    using Cell = LinearCellND&lt;T, 1&gt;;\n    using Vector = std::vector&lt;T&gt;;\n    using Span = std::span&lt;const T&gt;;\npublic:\n    LinearInterpND(const Vector &amp;_f, const Vector &amp;_x)\n      : indexer(_x)\n    {\n        assert(_x.size() == _f.size());\n        build(_x, _f);\n    }\n    ~LinearInterpND() { }\n\n    void build(const Vector &amp;x, const Vector &amp;f)\n    {\n        cells.reserve(x.size()-1);\n        for (int i = 0; i &lt; x.size()-1; ++i)\n        {\n            cells.push_back(Cell(Span(&amp;x[i], 2), Span(&amp;f[i], 2)));\n        }\n    }\n\n    T eval(const T xi) const\n    {\n        return cells[indexer.sort_index(xi)].eval(xi);\n    }\n\n    Vector evaln(const Vector &amp;xi) const\n    {\n        auto xi_iter = xi.begin();\n        Vector yi(xi.size());\n        for (auto &amp;yi_i : yi)\n        {\n            yi_i = eval(*xi_iter++);\n        }\n        return yi;\n    }\n\nprivate:\n    const cip::Indexer&lt;T&gt; indexer;\n    std::vector&lt;Cell&gt; cells;\n}; // class LinearInterpND case N=1\n\n\ntemplate &lt;typename T&gt;\nclass LinearInterp1D : public LinearInterpND&lt;T, 1&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    using Vector2 = cip::VectorN&lt;T, 1&gt;;\npublic:\n    explicit LinearInterp1D(const Vector &amp;x, const Vector &amp;f)\n    : LinearInterpND&lt;T, 1&gt;(f, x)\n    {}\n\n    ~LinearInterp1D() { }\n};\n\n\n\ntemplate &lt;typename T&gt;\nclass LinearInterp2D : public LinearInterpND&lt;T, 2&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    using Vector2 = cip::VectorN&lt;T, 2&gt;;\npublic:\n    explicit LinearInterp2D(const Vector &amp;x, const Vector &amp;y, const Vector2 &amp;f)\n    : LinearInterpND&lt;T, 2&gt;(f, x, y)\n    {}\n\n    ~LinearInterp2D() { }\n};\n\n\ntemplate &lt;typename T&gt;\nclass LinearInterp3D : public LinearInterpND&lt;T, 3&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    using Vector3 = cip::VectorN&lt;T, 3&gt;;\npublic:\n    explicit LinearInterp3D(const Vector &amp;x, const Vector &amp;y, const Vector &amp;z, const Vector3 &amp;f)\n    : LinearInterpND&lt;T, 3&gt;(f, x, y, z)\n    {}\n\n    ~LinearInterp3D() { }\n};\n\ntemplate &lt;typename T&gt;\nclass LinearInterp4D : public LinearInterpND&lt;T, 4&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    using Vector4 = cip::VectorN&lt;T, 4&gt;;\npublic:\n    explicit LinearInterp4D(const Vector &amp;x, const Vector &amp;y, const Vector &amp;z, const Vector &amp;w, const Vector4 &amp;f)\n    : LinearInterpND&lt;T, 4&gt;(f, x, y, z, w)\n    {}\n\n    ~LinearInterp4D() { }\n};\n\n} // namespace cip\n</code></pre>"},{"location":"reference/slopes_8hpp/","title":"File slopes.hpp","text":"<p>FileList &gt; include &gt; slopes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"reference/slopes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/slopes_8hpp/#classes","title":"Classes","text":"Type Name struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt; &lt;typename T, typename Tx, typename Tf&gt; struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt; &lt;typename T, typename Tx, typename Tf&gt; struct setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt; &lt;typename T, typename Tx, typename Tf&gt; <p>The documentation for this class was generated from the following file <code>include/slopes.hpp</code></p>"},{"location":"reference/slopes_8hpp_source/","title":"File slopes.hpp","text":"<p>File List &gt; include &gt; slopes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n\n\nnamespace cip {\n\n\ntemplate &lt;typename T, typename Tx, typename Tf&gt;\nstd::vector&lt;T&gt; monotonic_slopes(const Tx x, const Tf f)\n{\n\n    // See https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n    const auto nx = x.size();\n\n    std::vector&lt;T&gt; secants(nx-1);\n    std::vector&lt;T&gt; tangents(nx);\n\n    for (auto k = 0; k &lt; nx-1; ++k)\n    {\n        //secants[k] = (*(f_begin+k+1) - *(f_begin+k)) / (*(x_begin+k+1) - *(x_begin+k));\n        secants[k] = (f[k+1] - f[k]) / (x[k+1] - x[k]);\n    }\n\n    tangents[0] = secants[0];\n    for (auto k = 1; k &lt; nx-1; ++k)\n    {\n        tangents[k] = 0.5*(secants[k-1] + secants[k]);\n    }\n    tangents[nx-1] = secants[nx-2];\n\n    for (auto k = 0; k &lt; nx-1; ++k)\n    {\n        if (secants[k] == 0.0)\n        {\n            tangents[k] = 0.0;\n            tangents[k+1] = 0.0;\n        } else {\n            T alpha = tangents[k] / secants[k];\n            T beta = tangents[k + 1] / secants[k];\n            T h = std::hypot(alpha, beta);\n            if (h &gt; 3.0)\n            {\n                tangents[k] = 3.0/h*alpha*secants[k];\n                tangents[k+1] = 3.0/h*beta*secants[k];\n            }\n        }\n    }\n    return tangents;\n}\n\n\ntemplate &lt;typename T, typename Tx, typename Tf&gt;\nstd::vector&lt;T&gt; akima_slopes(const Tx x, const Tf f)\n{\n    /*\n    Derivative values for Akima cubic Hermite interpolation\n\n    Akima's derivative estimate at grid node x(i) requires the four finite\n    differences corresponding to the five grid nodes x(i-2:i+2).\n    For boundary grid nodes x(1:2) and x(n-1:n), append finite differences\n    which would correspond to x(-1:0) and x(n+1:n+2) by using the following\n    uncentered difference formula correspondin to quadratic extrapolation\n    using the quadratic polynomial defined by data at x(1:3)\n    (section 2.3 in Akima's paper):\n    */\n\n    const auto nx = x.size();\n\n    std::vector&lt;T&gt; delta(nx-1);\n    for (auto i = 0; i &lt; delta.size(); ++i)\n    {\n        delta[i] = (f[i+1] - f[i])/(x[i+1] - x[i]);\n    }\n\n    T delta_0 = 2.0*delta[0] - delta[1];\n    T delta_m1 = 2.0*delta_0 - delta[0];\n    T delta_n  = 2.0*delta[nx-2] - delta[nx-3];\n    T delta_n1 = 2.0*delta_n - delta[nx-2];\n\n    std::vector&lt;T&gt; delta_new(delta.size() + 4);\n    delta_new[0] = delta_m1;\n    delta_new[1] = delta_0;\n    delta_new[delta_new.size()-2] = delta_n;\n    delta_new[delta_new.size()-1] = delta_n1;\n    for (auto i = 0; i &lt; delta.size(); ++i)\n    {\n        delta_new[i+2] = delta[i];\n    }\n\n    /*\n    Akima's derivative estimate formula (equation (1) in the paper):\n\n            H. Akima, \"A New Method of Interpolation and Smooth Curve Fitting\n            Based on Local Procedures\", JACM, v. 17-4, p.589-602, 1970.\n\n        s(i) = (|d(i+1)-d(i)| * d(i-1) + |d(i-1)-d(i-2)| * d(i))\n             / (|d(i+1)-d(i)|          + |d(i-1)-d(i-2)|)\n    */\n\n    std::vector&lt;T&gt; weights(delta_new.size() - 1);\n    for (auto i = 0; i &lt; weights.size(); ++i)\n    {\n        weights[i] = std::abs(delta_new[i+1] - delta_new[i]) + std::abs(delta_new[i] + delta_new[i+1])/2.0;\n    }\n\n    std::vector&lt;T&gt; s(nx);\n\n    for (auto i = 0; i &lt; nx; ++i)\n    {\n        T weights1 = weights[i];   // |d(i-1)-d(i-2)|\n        T weights2 = weights[i+2]; // |d(i+1)-d(i)|\n        T delta1 = delta_new[i+1];     // d(i-1)\n        T delta2 = delta_new[i+2];     // d(i)\n        T weights12 = weights1 + weights2;\n        if (weights12 == 0.0)\n        {\n            // To avoid 0/0, Akima proposed to average the divided differences d(i-1)\n            // and d(i) for the edge case of d(i-2) = d(i-1) and d(i) = d(i+1):\n            s[i] = 0.5*(delta1 + delta2);\n        } else {\n            s[i] = (weights2*delta1 + weights1*delta2)/weights12;\n        }\n    }\n    return s;\n}\n\n\nenum class BoundaryConditionType {\n    Natural,\n    Clamped,\n    NotAKnot\n};\n\n\ntemplate &lt;BoundaryConditionType BC, typename T, typename Tx, typename Tf&gt;\nstruct setNaturalSplineBoundaryCondition;\n\n\ntemplate &lt;typename T, typename Tx, typename Tf&gt;\nstruct setNaturalSplineBoundaryCondition&lt;BoundaryConditionType::Natural, T, Tx, Tf&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    constexpr void operator()(const Tx&amp; x, const Tf&amp; f, Vector&amp; a, Vector&amp; b, Vector&amp; c, Vector&amp; d) const {\n        T dx1 = x[1] - x[0];\n        b[0] = 2.0/dx1;\n        c[0] = 1.0/dx1;\n        d[0] = 3.0*(f[1] - f[0])/(dx1*dx1);\n\n        const auto nx = x.size();\n        T dxN = x[nx-1] - x[nx-2];\n        a[nx-1] = 1.0/dxN;\n        b[nx-1] = 2.0/dxN;\n        d[nx-1] = 3.0*(f[nx-1] - f[nx-2])/(dxN*dxN);\n    }\n};\n\n\ntemplate &lt;typename T, typename Tx, typename Tf&gt;\nstruct setNaturalSplineBoundaryCondition&lt;BoundaryConditionType::NotAKnot, T, Tx, Tf&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    constexpr void operator()(const Tx&amp; x, const Tf&amp; f, Vector&amp; a, Vector&amp; b, Vector&amp; c, Vector&amp; d) const {\n        T dx1 = x[1] - x[0];\n        T dx2 = x[2] - x[1];\n        b[0] = 1.0/(dx1*dx1);\n        c[0] = b[0] - 1.0/(dx2*dx2);\n        d[0] = 2.0*((f[1] - f[0])/(dx1*dx1*dx1) - (f[2] - f[1])/(dx2*dx2*dx2));\n\n        // necessary conversion to maintain a tridiagonal matrix\n        b[0] += a[1]/dx2;\n        c[0] += b[1]/dx2;\n        d[0] += d[1]/dx2;\n\n        const auto nx = x.size();\n        T dxN1 = x[nx-1] - x[nx-2];\n        T dxN2 = x[nx-2] - x[nx-3];\n        a[nx-1] = 1.0/(dxN1*dxN1) - 1.0/(dxN2*dxN2);\n        b[nx-1] = -1.0/(dxN2*dxN2);\n        d[nx-1] = 2.0*((f[nx-2] - f[nx-3])/(dxN2*dxN2*dxN2) - (f[nx-1] - f[nx-2])/(dxN1*dxN1*dxN1));\n\n        // necessary conversion to maintain a tridiagonal matrix\n        a[nx-1] -= b[nx-2]/dxN2;\n        b[nx-1] -= c[nx-2]/dxN2;\n        d[nx-1] -= d[nx-2]/dxN2;\n    }\n};\n\n\ntemplate &lt;typename T, typename Tx, typename Tf&gt;\nstruct setNaturalSplineBoundaryCondition&lt;BoundaryConditionType::Clamped, T, Tx, Tf&gt; {\n    using Vector = std::vector&lt;T&gt;;\n    constexpr void operator()(const Tx&amp; x, const Tf&amp; f, Vector&amp; a, Vector&amp; b, Vector&amp; c, Vector&amp; d) const {\n        // Demand the slopes to be zero at the boundaries\n        b[0] = T{1};\n        const auto nx = x.size();\n        b[nx-1] = T{1};\n    }\n};\n\n\ntemplate &lt;typename T&gt;\nvoid thomas_algorithm(const std::vector&lt;T&gt; &amp;a, const std::vector&lt;T&gt; &amp;b, std::vector&lt;T&gt; &amp;c, std::vector&lt;T&gt; &amp;d)\n{\n    auto nd = d.size();\n\n    c[0] /= b[0];\n    d[0] /= b[0];\n\n    nd--;\n    for (auto i = 1; i &lt; nd; i++) {\n        c[i] /= b[i] - a[i]*c[i-1];\n        d[i] = (d[i] - a[i]*d[i-1]) / (b[i] - a[i]*c[i-1]);\n    }\n\n    d[nd] = (d[nd] - a[nd]*d[nd-1]) / (b[nd] - a[nd]*c[nd-1]);\n\n    for (auto i = nd; i-- &gt; 0;) {\n        d[i] -= c[i]*d[i+1];\n    }\n}\n\n\ntemplate &lt;typename T, BoundaryConditionType BC=BoundaryConditionType::Natural, typename Tx, typename Tf&gt;\nstd::vector&lt;T&gt; natural_spline_slopes(const Tx x, const Tf f)\n{\n    // https://en.wikipedia.org/wiki/Spline_interpolation\n\n    const auto nx = x.size();\n\n    // vectors that fill up the tridiagonal matrix\n    std::vector&lt;T&gt; a(nx, T{0}); // first value of a is not used\n    std::vector&lt;T&gt; b(nx, T{0});\n    std::vector&lt;T&gt; c(nx, T{0}); // last value of c is not used\n    // right hand side\n    std::vector&lt;T&gt; d(nx, T{0});\n\n    // rows i = 1, ..., nx-2\n    for (auto i = 1; i &lt; nx-1; ++i)\n    {\n        T dxi = x[i] - x[i-1];\n        T dxi1 = x[i+1] - x[i];\n        a[i] = 1.0/dxi;\n        b[i] = 2.0*(1.0/dxi + 1.0/dxi1);\n        c[i] = 1.0/dxi1;\n        d[i] = 3.0*((f[i] - f[i-1])/(dxi*dxi) + (f[i+1] - f[i])/(dxi1*dxi1));\n    }\n\n    setNaturalSplineBoundaryCondition&lt;BC, T, Tx, Tf&gt;{}(x, f, a, b, c, d);\n\n    thomas_algorithm&lt;T&gt;(a, b, c, d);\n\n    return d;\n}\n\n\n} // namespace cip\n</code></pre>"},{"location":"reference/utils_8hpp/","title":"File utils.hpp","text":"<p>FileList &gt; include &gt; utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> </ul>"},{"location":"reference/utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/utils_8hpp/#classes","title":"Classes","text":"Type Name class Indexer &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>include/utils.hpp</code></p>"},{"location":"reference/utils_8hpp_source/","title":"File utils.hpp","text":"<p>File List &gt; include &gt; utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\n\nnamespace cip {\n\n\ntemplate &lt;typename T&gt;\nclass Indexer {\n    using Vector = std::vector&lt;T&gt;;\npublic:\n    Indexer(const Vector &amp;_x)\n    : x(_x),\n      index_back(x.size()-2),\n      x_front(x[index_front]),\n      x_back(x[x.size()-1]),\n      x_delta((x_back-x_front)/(x.size()-1))\n    {\n    }\n    ~Indexer() { }\n\n    const std::size_t cell_index(const T xi) const\n    {\n        return\n        (xi &lt; x_back) ?\n            ((xi &lt; x_front) ?\n                index_front :\n                (std::size_t)((xi-x_front)/x_delta)) :\n            index_back;\n    }\n\n    const std::size_t sort_index(const T xi) const\n    {\n        if (xi &lt; x_front)\n        {\n            return index_front;\n        }\n        if (xi &gt;= x_back)\n        {\n            return index_back;\n        }\n        return std::distance(x.begin(), std::upper_bound(x.begin(), x.end(), xi)) - 1;\n    }\n\nprivate:\n    const Vector x;\n    const size_t index_front = 0;\n    const size_t index_back;\n    const T x_front;\n    const T x_back;\n    const T x_delta;\n};\n\n\n\nconstexpr inline int factorial(int n)\n{\n    return n &lt;= 1 ? 1 : (n * factorial(n - 1));\n}\n\n\nconstexpr inline std::size_t binomial(std::size_t n, std::size_t k) noexcept\n{\n    return\n      (        k&gt; n  )? 0 :          // out of range\n      (k==0 || k==n  )? 1 :          // edge\n      (k==1 || k==n-1)? n :          // first\n      (     k+k &lt; n  )?              // recursive:\n      (binomial(n-1,k-1) * n)/k :    //  path to k=1   is faster\n      (binomial(n-1,k) * n)/(n-k);   //  path to k=n-1 is faster\n}\n\n\ntemplate &lt;typename T&gt;\nT binomial_power_coefficient(const T y, const int n, const int k)\n{\n    return binomial(n, k)*std::pow(y, n-k);\n}\n\n\ntemplate &lt;std::size_t Base, std::size_t Exp&gt;\nconstexpr std::size_t power()\n{\n    if constexpr (Exp &lt;= 0)\n    {\n        return 1;\n    } else {\n        return Base*power&lt;Base, Exp-1&gt;();\n    }\n}\n\n\n} // namespace cip\n</code></pre>"},{"location":"reference/vectorn_8hpp/","title":"File vectorn.hpp","text":"<p>FileList &gt; include &gt; vectorn.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;mdspan/mdspan.hpp&gt;</code></li> </ul>"},{"location":"reference/vectorn_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cip"},{"location":"reference/vectorn_8hpp/#classes","title":"Classes","text":"Type Name class VectorN &lt;typename T, N&gt; <p>The documentation for this class was generated from the following file <code>include/vectorn.hpp</code></p>"},{"location":"reference/vectorn_8hpp_source/","title":"File vectorn.hpp","text":"<p>File List &gt; include &gt; vectorn.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n#include &lt;mdspan/mdspan.hpp&gt;\n\n\nnamespace cip {\n\n\n// VectorN definition template\ntemplate &lt;typename T, std::size_t N&gt;\nclass VectorN {\n    using Mdspan = std::mdspan&lt;T, std::dextents&lt;std::size_t, N&gt;, std::layout_stride&gt;;\n    using Mdspan1D = std::mdspan&lt;T, std::dextents&lt;std::size_t, 1&gt;, std::layout_stride&gt;;\n    using IndexArray = std::array&lt;std::size_t, N&gt;;\npublic:\n    // Constructor from dimensions and initial value\n    VectorN(const T&amp; initial_value, const IndexArray&amp; dimensions)\n        : dimensions_(dimensions), data_(calculate_total_size(dimensions), initial_value),\n          mdspan(std::mdspan(data_.data(), dimensions_))\n    {\n    }\n\n    // Copy constructor\n    VectorN(const VectorN &amp;other)\n    : data_(other.data_), \n      dimensions_(other.dimensions_), \n      mdspan(std::mdspan(data_.data(), dimensions_))\n    {\n    }\n\n    // Constructor from nested vectors\n    template &lt;typename NestedVector&gt;\n    VectorN(const NestedVector&amp; nested)\n        : dimensions_(determine_dimensions&lt;NestedVector, N&gt;(nested)) {\n        data_.reserve(calculate_total_size(dimensions_));\n        Flatten&lt;NestedVector, N&gt;::apply(nested, data_);\n        mdspan = std::mdspan(data_.data(), dimensions_);\n    }\n\n    // Constructor from just dimensions\n    VectorN(const IndexArray&amp; dimensions)\n        : dimensions_(dimensions)\n    {\n        data_.reserve(calculate_total_size(dimensions));\n        mdspan = std::mdspan(data_.data(), dimensions_);\n    }\n\n    // Access elements using variadic indices\n    template &lt;typename... Indices&gt;\n    T&amp; operator()(Indices... indices) {\n        static_assert(sizeof...(Indices) == N, \"Incorrect number of indices\");\n        return mdspan(std::forward&lt;Indices&gt;(indices)...);\n    }\n\n    template &lt;typename... Indices&gt;\n    const T&amp; operator()(Indices... indices) const {\n        static_assert(sizeof...(Indices) == N, \"Incorrect number of indices\");\n        return mdspan(std::forward&lt;Indices&gt;(indices)...);\n    }\n\n    // access elements using std::array indices\n    T&amp; operator()(IndexArray&amp; indices) {\n        return mdspan(std::forward&lt;IndexArray&gt;(indices));\n    }\n\n    template &lt;typename... Indices&gt;\n    const T&amp; operator()(IndexArray&amp; indices) const {\n        return mdspan(std::forward&lt;IndexArray&gt;(indices));\n    }\n\n    template &lt;typename... Args&gt;\n    void emplace_back(Args... args) {\n        data_.emplace_back(std::forward&lt;Args&gt;(args)...);\n    }\n\n    Mdspan get_mdspan() {\n        return mdspan;\n    }\n\n    const Mdspan get_mdspan() const {\n        return mdspan;\n    }\n\n    template &lt;typename... Pairs&gt;\n    Mdspan submdspan(Pairs&amp;&amp;... pairs) const {\n        return std::submdspan(mdspan, std::forward&lt;Pairs&gt;(pairs)...);\n    }\n\n    template &lt;typename... Pairs&gt;\n    Mdspan submdspan(Pairs&amp;&amp;... pairs) {\n        return std::submdspan(mdspan, std::forward&lt;Pairs&gt;(pairs)...);\n    }\n\n\n    template &lt;typename... SliceArgs&gt;\n    Mdspan1D submdspan_1d(SliceArgs&amp;&amp;... args) {\n        return std::submdspan(mdspan, std::forward&lt;SliceArgs&gt;(args)...);\n    }\n\n\n    // This method takes an rvalue 1D vector and moves its contents into a subview of the ND\n    // vector. The additional slice specifiers must yield a 1D submdspan.\n    template &lt;typename... SliceSpecs&gt;\n    void move_into_submdspan(std::vector&lt;T&gt;&amp;&amp; source, SliceSpecs&amp;&amp;... specs) {\n        // Obtain the subview using your existing submdspan function.\n        auto subview = std::submdspan(mdspan, std::forward&lt;SliceSpecs&gt;(specs)...);\n        static_assert(decltype(subview)::rank() == 1, \"The submdspan must be 1-dimensional.\");\n\n        // Check at runtime that the source vector has the same number of elements\n        // as the extent of the 1D subview.\n        if (subview.extent(0) != source.size()) {\n            throw std::runtime_error(\"Size mismatch: source vector size does not match subview extent\");\n        }\n        // Use std::move to transfer the elements.\n        // Due to strided layout, the elements are not contiguous in memory.\n        for (std::size_t i = 0; i &lt; subview.extent(0); ++i) {\n            subview(i) = std::move(source[i]);\n        }\n    }\n\n    // Move a lower-dimensional VectorN into a submdspan of this VectorN, using the source's\n    // operator()(const IndexArray&amp;) to access its elements.\n    template &lt;std::size_t M, typename... SliceSpecs&gt;\n    void move_into_submdspan(VectorN&lt;T, M&gt;&amp;&amp; source, SliceSpecs&amp;&amp;... specs) {\n        // Obtain the target subview.\n        auto subview = std::submdspan(mdspan, std::forward&lt;SliceSpecs&gt;(specs)...);\n        static_assert(decltype(subview)::rank() == M,\n                    \"The submdspan must have rank equal to the source VectorN.\");\n\n        constexpr std::size_t rank = decltype(subview)::rank();\n\n        // Get extents from the target subview.\n        std::array&lt;std::size_t, rank&gt; targetExtents;\n        std::size_t targetTotal = 1;\n        for (std::size_t d = 0; d &lt; rank; ++d) {\n            targetExtents[d] = subview.extent(d);\n            targetTotal *= targetExtents[d];\n        }\n\n        // Get extents from the source VectorN.\n        const auto&amp; srcDims = source.dimensions();\n        std::array&lt;std::size_t, M&gt; srcExtents = srcDims; // source.dimensions() returns an std::array&lt;std::size_t, M&gt;\n        std::size_t srcTotal = 1;\n        for (std::size_t d = 0; d &lt; M; ++d) {\n            srcTotal *= srcExtents[d];\n        }\n\n        if (srcTotal != targetTotal) {\n            throw std::runtime_error(\"Size mismatch: source VectorN size does not match target subview total size\");\n        }\n\n        // Use a recursive lambda to iterate over all multi-index combinations.\n        std::array&lt;std::size_t, rank&gt; indexArray{};\n        auto recursiveFill = [&amp;](auto&amp; self, std::size_t dim) -&gt; void {\n            if (dim == rank) {\n                // For each multi-index, use source.operator()(indexArray) to access the element.\n                subview(indexArray) = std::move(source(indexArray));\n            } else {\n                for (std::size_t i = 0; i &lt; targetExtents[dim]; ++i) {\n                    indexArray[dim] = i;\n                    self(self, dim + 1);\n                }\n            }\n        };\n        recursiveFill(recursiveFill, 0);\n    }\n\n\n    const IndexArray&amp; dimensions() const { return dimensions_; }\n    const std::vector&lt;T&gt;&amp; data() const { return data_; }\n\nprivate:\n    IndexArray dimensions_;\n    std::vector&lt;T&gt; data_;\n    Mdspan mdspan;\n\n    // Utility to calculate total size of the N-dimensional array.\n    constexpr std::size_t calculate_total_size(const std::array&lt;std::size_t, N&gt;&amp; dimensions) {\n        std::size_t total_size = 1;\n        for (std::size_t dim : dimensions) {\n            total_size *= dim;\n        }\n        return total_size;\n    }\n\n    // Recursive template to handle nested std::vector flattening\n    template &lt;typename NestedVector, std::size_t Rank&gt;\n    struct Flatten {\n        static void apply(const NestedVector&amp; nested, std::vector&lt;T&gt;&amp; flat) {\n            for (const auto&amp; inner : nested) {\n                Flatten&lt;typename NestedVector::value_type, Rank - 1&gt;::apply(inner, flat);\n            }\n        }\n    };\n\n    template &lt;typename NestedVector&gt;\n    struct Flatten&lt;NestedVector, 1&gt; {\n        static void apply(const NestedVector&amp; nested, std::vector&lt;T&gt;&amp; flat) {\n            flat.insert(flat.end(), nested.begin(), nested.end());\n        }\n    };\n\n    // General template to determine dimensions of a nested vector\n    template &lt;typename NestedVector, std::size_t Rank&gt;\n    std::array&lt;std::size_t, Rank&gt; determine_dimensions(const NestedVector&amp; vec) {\n        static_assert(Rank &gt; 0, \"Rank must be greater than 0\");\n        std::array&lt;std::size_t, Rank&gt; dimensions{};\n        dimensions[0] = vec.size();\n        if constexpr (Rank &gt; 1) {\n            if (!vec.empty()) {\n                // Recursively call determine_dimensions on the first element of the vector\n                auto sub_dimensions = determine_dimensions&lt;typename NestedVector::value_type, Rank - 1&gt;(vec[0]);\n                std::copy(sub_dimensions.begin(), sub_dimensions.end(), dimensions.begin() + 1);\n            }\n        }\n        return dimensions;\n    }\n\n};\n\n\n} // namespace cip\n</code></pre>"},{"location":"reference/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"reference/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file cubinterpp_py_module.cpp <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"reference/cubinterpp__py__module_8cpp/","title":"File cubinterpp_py_module.cpp","text":"<p>FileList &gt; src &gt; cubinterpp_py_module.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;pybind11/stl.h&gt;</code></li> <li><code>#include &lt;pybind11/pybind11.h&gt;</code></li> <li><code>#include &lt;cubinterpp.hpp&gt;</code></li> </ul>"},{"location":"reference/cubinterpp__py__module_8cpp/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; double &gt; DoubleVector typedef std::vector&lt; DoubleVector &gt; DoubleVector2 typedef std::vector&lt; DoubleVector2 &gt; DoubleVector3"},{"location":"reference/cubinterpp__py__module_8cpp/#public-functions","title":"Public Functions","text":"Type Name PYBIND11_MODULE (cubinterpp_py, m)"},{"location":"reference/cubinterpp__py__module_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"reference/cubinterpp__py__module_8cpp/#typedef-doublevector","title":"typedef DoubleVector","text":"<pre><code>using DoubleVector =  std::vector&lt;double&gt;;\n</code></pre>"},{"location":"reference/cubinterpp__py__module_8cpp/#typedef-doublevector2","title":"typedef DoubleVector2","text":"<pre><code>using DoubleVector2 =  std::vector&lt;DoubleVector&gt;;\n</code></pre>"},{"location":"reference/cubinterpp__py__module_8cpp/#typedef-doublevector3","title":"typedef DoubleVector3","text":"<pre><code>using DoubleVector3 =  std::vector&lt;DoubleVector2&gt;;\n</code></pre>"},{"location":"reference/cubinterpp__py__module_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"reference/cubinterpp__py__module_8cpp/#function-pybind11_module","title":"function PYBIND11_MODULE","text":"<pre><code>PYBIND11_MODULE (\n    cubinterpp_py,\n    m\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/cubinterpp_py_module.cpp</code></p>"},{"location":"reference/cubinterpp__py__module_8cpp_source/","title":"File cubinterpp_py_module.cpp","text":"<p>File List &gt; src &gt; cubinterpp_py_module.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;vector&gt;\n#include &lt;pybind11/stl.h&gt;\n#include &lt;pybind11/pybind11.h&gt;\n#include &lt;cubinterpp.hpp&gt;\n\nnamespace py = pybind11;\n\nusing DoubleVector = std::vector&lt;double&gt;;\nusing DoubleVector2 = std::vector&lt;DoubleVector&gt;;\nusing DoubleVector3 = std::vector&lt;DoubleVector2&gt;;\n\n\nPYBIND11_MODULE(cubinterpp_py, m) {\n    m.doc() = \"pybind11 1D cubic and linear interpolation\"; // optional module docstring\n\n    py::class_&lt;cip::LinearInterp1D&lt;double&gt;&gt;(m, \"LinearInterp1D\")\n        .def(py::init&lt;DoubleVector, DoubleVector&gt;())\n        .def(\"eval\", &amp;cip::LinearInterp1D&lt;double&gt;::eval, py::return_value_policy::reference_internal)\n        .def(\"evaln\", &amp;cip::LinearInterp1D&lt;double&gt;::evaln, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::MonotonicSpline1D&lt;double&gt;&gt;(m, \"MonotonicSpline1D\")\n        .def(py::init&lt;DoubleVector, DoubleVector&gt;())\n        .def(\"eval\", &amp;cip::MonotonicSpline1D&lt;double&gt;::eval, py::return_value_policy::reference_internal)\n        .def(\"evaln\", &amp;cip::MonotonicSpline1D&lt;double&gt;::evaln, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::AkimaSpline1D&lt;double&gt;&gt;(m, \"AkimaSpline1D\")\n        .def(py::init&lt;DoubleVector, DoubleVector&gt;())\n        .def(\"eval\", &amp;cip::AkimaSpline1D&lt;double&gt;::eval, py::return_value_policy::reference_internal)\n        .def(\"evaln\", &amp;cip::AkimaSpline1D&lt;double&gt;::evaln, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::NaturalSpline1D&lt;double&gt;&gt;(m, \"NaturalSpline1D\")\n        .def(py::init&lt;DoubleVector, DoubleVector&gt;())\n        .def(\"eval\", &amp;cip::NaturalSpline1D&lt;double&gt;::eval, py::return_value_policy::reference_internal)\n        .def(\"evaln\", &amp;cip::NaturalSpline1D&lt;double&gt;::evaln, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::LinearInterp2D&lt;double&gt;&gt;(m, \"LinearInterp2D\")\n        .def(py::init&lt;DoubleVector, DoubleVector, DoubleVector2&gt;())\n        .def(\"eval\", &amp;cip::LinearInterp2D&lt;double&gt;::eval&lt;double, double&gt;, py::return_value_policy::reference_internal)\n        .def(\"evaln\", &amp;cip::LinearInterp2D&lt;double&gt;::evaln&lt;DoubleVector, DoubleVector&gt;, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::LinearInterp3D&lt;double&gt;&gt;(m, \"LinearInterp3D\")\n        .def(py::init&lt;DoubleVector, DoubleVector, DoubleVector, DoubleVector3&gt;())\n        .def(\"eval\", &amp;cip::LinearInterp3D&lt;double&gt;::eval&lt;double, double, double&gt;, py::return_value_policy::reference_internal)\n        .def(\"evaln\", &amp;cip::LinearInterp3D&lt;double&gt;::evaln&lt;DoubleVector, DoubleVector, DoubleVector&gt;, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::MonotonicSpline2D&lt;double&gt;&gt;(m, \"MonotonicSpline2D\")\n        .def(py::init&lt;DoubleVector, DoubleVector, DoubleVector2&gt;())\n        .def(\"eval\", &amp;cip::MonotonicSpline2D&lt;double&gt;::eval&lt;double, double&gt;, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::AkimaSpline2D&lt;double&gt;&gt;(m, \"AkimaSpline2D\")\n        .def(py::init&lt;DoubleVector, DoubleVector, DoubleVector2&gt;())\n        .def(\"eval\", &amp;cip::AkimaSpline2D&lt;double&gt;::eval&lt;double, double&gt;, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::NaturalSpline2D&lt;double&gt;&gt;(m, \"NaturalSpline2D\")\n        .def(py::init&lt;DoubleVector, DoubleVector, DoubleVector2&gt;())\n        .def(\"eval\", &amp;cip::NaturalSpline2D&lt;double&gt;::eval&lt;double, double&gt;, py::return_value_policy::reference_internal);\n\n    py::class_&lt;cip::NaturalSpline3D&lt;double&gt;&gt;(m, \"NaturalSpline3D\")\n        .def(py::init&lt;DoubleVector, DoubleVector, DoubleVector, DoubleVector3&gt;())\n        .def(\"eval\", &amp;cip::NaturalSpline3D&lt;double&gt;::eval&lt;double, double, double&gt;, py::return_value_policy::reference_internal);\n\n}\n</code></pre>"},{"location":"reference/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cip </li> </ul>"},{"location":"reference/classes/","title":"Class Index","text":""},{"location":"reference/classes/#a","title":"a","text":"<ul> <li>AkimaSpline1D (cip)</li> <li>AkimaSpline2D (cip)</li> </ul>"},{"location":"reference/classes/#c","title":"c","text":"<ul> <li>CubicCellND (cip)</li> <li>CubicCellND&lt; T, 1 &gt; (cip)</li> <li>CubicInterpND (cip)</li> <li>CubicInterpND&lt; T, 1 &gt; (cip)</li> </ul>"},{"location":"reference/classes/#f","title":"f","text":"<ul> <li>Flatten</li> <li>Flatten&lt; NestedVector, 1 &gt;</li> </ul>"},{"location":"reference/classes/#i","title":"i","text":"<ul> <li>Indexer (cip)</li> </ul>"},{"location":"reference/classes/#l","title":"l","text":"<ul> <li>LinearCellND (cip)</li> <li>LinearCellND&lt; T, 1 &gt; (cip)</li> <li>LinearInterp1D (cip)</li> <li>LinearInterp2D (cip)</li> <li>LinearInterp3D (cip)</li> <li>LinearInterp4D (cip)</li> <li>LinearInterpND (cip)</li> <li>LinearInterpND&lt; T, 1 &gt; (cip)</li> </ul>"},{"location":"reference/classes/#m","title":"m","text":"<ul> <li>MonotonicSpline1D (cip)</li> <li>MonotonicSpline2D (cip)</li> </ul>"},{"location":"reference/classes/#n","title":"n","text":"<ul> <li>NaturalSpline1D (cip)</li> <li>NaturalSpline2D (cip)</li> <li>NaturalSpline3D (cip)</li> </ul>"},{"location":"reference/classes/#s","title":"s","text":"<ul> <li>setNaturalSplineBoundaryCondition (cip)</li> <li>setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt; (cip)</li> <li>setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt; (cip)</li> <li>setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt; (cip)</li> </ul>"},{"location":"reference/classes/#v","title":"v","text":"<ul> <li>VectorN (cip)</li> </ul>"},{"location":"reference/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class cip::CubicInterpND <ul> <li>class cip::AkimaSpline1D </li> <li>class cip::AkimaSpline2D </li> <li>class cip::MonotonicSpline1D </li> <li>class cip::MonotonicSpline2D </li> <li>class cip::NaturalSpline1D </li> <li>class cip::NaturalSpline2D </li> <li>class cip::NaturalSpline3D </li> </ul> </li> <li>class cip::CubicCellND </li> <li>class cip::CubicCellND&lt; T, 1 &gt; </li> <li>class cip::CubicInterpND&lt; T, 1 &gt; </li> <li>class cip::Indexer </li> <li>class cip::LinearCellND </li> <li>class cip::LinearCellND&lt; T, 1 &gt; </li> <li>class cip::LinearInterpND&lt; T, 1 &gt; <ul> <li>class cip::LinearInterp1D </li> </ul> </li> <li>class cip::LinearInterpND </li> <li>class cip::VectorN </li> <li>struct cip::setNaturalSplineBoundaryCondition </li> <li>struct cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt; </li> <li>struct cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt; </li> <li>struct cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt; </li> <li>struct cip::VectorN::Flatten </li> <li>struct cip::VectorN::Flatten&lt; NestedVector, 1 &gt; </li> </ul>"},{"location":"reference/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"reference/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"reference/class_members/","title":"Class Members","text":""},{"location":"reference/class_members/#a","title":"a","text":"<ul> <li>AkimaSpline1D (cip::AkimaSpline1D)</li> <li>AkimaSpline2D (cip::AkimaSpline2D)</li> <li>Array (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::LinearInterpND)</li> <li>Array2 (cip::CubicCellND)</li> <li>ArrayN (cip::CubicCellND)</li> <li>Alpha (cip::CubicCellND&lt; T, 1 &gt;)</li> <li>a0 (cip::LinearCellND&lt; T, 1 &gt;)</li> <li>apply (cip::VectorN::Flatten, cip::VectorN::Flatten&lt; NestedVector, 1 &gt;)</li> </ul>"},{"location":"reference/class_members/#b","title":"b","text":"<ul> <li>build (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>build_cell (cip::CubicInterpND, cip::LinearInterpND)</li> <li>b0 (cip::LinearCellND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_members/#c","title":"c","text":"<ul> <li>calc_slopes (cip::AkimaSpline1D, cip::AkimaSpline2D, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::MonotonicSpline1D, cip::MonotonicSpline2D, cip::NaturalSpline1D, cip::NaturalSpline2D, cip::NaturalSpline3D)</li> <li>CoeffsArray (cip::CubicCellND)</li> <li>CubicCellND (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>calc_coeffs (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>calc_delta (cip::CubicCellND)</li> <li>calc_delta_ij (cip::CubicCellND)</li> <li>calc_h (cip::CubicCellND)</li> <li>calc_h3 (cip::CubicCellND)</li> <li>coeffs (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>Cell (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>Cells (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND)</li> <li>CubicInterpND (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;)</li> <li>cells (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>cell_index (cip::Indexer)</li> <li>c (cip::LinearCellND)</li> <li>compute_c_J (cip::LinearCellND)</li> <li>compute_coefficients (cip::LinearCellND)</li> <li>compute_corner (cip::LinearCellND)</li> <li>calculate_total_size (cip::VectorN)</li> </ul>"},{"location":"reference/class_members/#d","title":"d","text":"<ul> <li>Delta (cip::CubicCellND)</li> <li>data (cip::VectorN)</li> <li>data_ (cip::VectorN)</li> <li>determine_dimensions (cip::VectorN)</li> <li>dimensions (cip::VectorN)</li> <li>dimensions_ (cip::VectorN)</li> </ul>"},{"location":"reference/class_members/#e","title":"e","text":"<ul> <li>eval (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearCellND, cip::LinearCellND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>eval_poly (cip::CubicCellND)</li> <li>evaln (cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>emplace_back (cip::VectorN)</li> </ul>"},{"location":"reference/class_members/#f","title":"f","text":"<ul> <li>F (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND)</li> <li>Ff (cip::CubicInterpND)</li> <li>Ff2 (cip::CubicInterpND)</li> <li>f (cip::LinearCellND, cip::LinearInterpND)</li> </ul>"},{"location":"reference/class_members/#g","title":"g","text":"<ul> <li>gamma (cip::LinearCellND)</li> <li>gather_corners (cip::LinearCellND)</li> <li>get_mdspan (cip::VectorN)</li> </ul>"},{"location":"reference/class_members/#h","title":"h","text":"<ul> <li>H (cip::LinearCellND)</li> </ul>"},{"location":"reference/class_members/#i","title":"i","text":"<ul> <li>Indexers (cip::CubicInterpND, cip::LinearInterpND)</li> <li>indexers (cip::CubicInterpND, cip::LinearInterpND)</li> <li>indexer (cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>Indexer (cip::Indexer)</li> <li>index_back (cip::Indexer)</li> <li>index_front (cip::Indexer)</li> <li>IndexArray (cip::VectorN)</li> </ul>"},{"location":"reference/class_members/#l","title":"l","text":"<ul> <li>LinearCellND (cip::LinearCellND, cip::LinearCellND&lt; T, 1 &gt;)</li> <li>LinearInterp1D (cip::LinearInterp1D)</li> <li>LinearInterp2D (cip::LinearInterp2D)</li> <li>LinearInterp3D (cip::LinearInterp3D)</li> <li>LinearInterp4D (cip::LinearInterp4D)</li> <li>LinearInterpND (cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_members/#m","title":"m","text":"<ul> <li>Mdspan1D (cip::AkimaSpline2D, cip::CubicInterpND, cip::MonotonicSpline2D, cip::NaturalSpline2D, cip::NaturalSpline3D, cip::VectorN)</li> <li>Mdspan (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::LinearCellND, cip::VectorN)</li> <li>MonotonicSpline1D (cip::MonotonicSpline1D)</li> <li>MonotonicSpline2D (cip::MonotonicSpline2D)</li> <li>mdspan (cip::VectorN)</li> <li>move_into_submdspan (cip::VectorN)</li> </ul>"},{"location":"reference/class_members/#n","title":"n","text":"<ul> <li>numCoeffs (cip::CubicCellND)</li> <li>numCorners (cip::CubicCellND, cip::LinearCellND)</li> <li>NomArray (cip::LinearCellND)</li> <li>NaturalSpline1D (cip::NaturalSpline1D)</li> <li>NaturalSpline2D (cip::NaturalSpline2D)</li> <li>NaturalSpline3D (cip::NaturalSpline3D)</li> </ul>"},{"location":"reference/class_members/#o","title":"o","text":"<ul> <li>order (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>operator() (cip::VectorN, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;)</li> </ul>"},{"location":"reference/class_members/#p","title":"p","text":"<ul> <li>Pr (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND)</li> <li>populate_F (cip::CubicInterpND)</li> </ul>"},{"location":"reference/class_members/#s","title":"s","text":"<ul> <li>Span (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearCellND, cip::LinearCellND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>Spans (cip::CubicCellND, cip::LinearCellND)</li> <li>size_t_two (cip::CubicInterpND)</li> <li>sort_index (cip::Indexer)</li> <li>submdspan (cip::VectorN)</li> <li>submdspan_1d (cip::VectorN)</li> </ul>"},{"location":"reference/class_members/#v","title":"v","text":"<ul> <li>Vector (cip::AkimaSpline1D, cip::AkimaSpline2D, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::Indexer, cip::LinearInterp1D, cip::LinearInterp2D, cip::LinearInterp3D, cip::LinearInterp4D, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;, cip::MonotonicSpline1D, cip::MonotonicSpline2D, cip::NaturalSpline1D, cip::NaturalSpline2D, cip::NaturalSpline3D, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;)</li> <li>VectorN (cip::AkimaSpline2D, cip::MonotonicSpline2D, cip::NaturalSpline2D, cip::NaturalSpline3D, cip::VectorN)</li> <li>VectorN2 (cip::CubicInterpND&lt; T, 1 &gt;)</li> <li>Vector2 (cip::LinearInterp1D, cip::LinearInterp2D)</li> <li>Vector3 (cip::LinearInterp3D)</li> <li>Vector4 (cip::LinearInterp4D)</li> </ul>"},{"location":"reference/class_members/#x","title":"x","text":"<ul> <li>x (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::Indexer, cip::LinearCellND)</li> <li>xi (cip::CubicInterpND, cip::LinearInterpND)</li> <li>x_back (cip::Indexer)</li> <li>x_delta (cip::Indexer)</li> <li>x_front (cip::Indexer)</li> <li>x0 (cip::LinearCellND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_members/#y","title":"y","text":"<ul> <li>y (cip::CubicInterpND)</li> </ul>"},{"location":"reference/class_members/#_1","title":"~","text":"<ul> <li>~AkimaSpline1D (cip::AkimaSpline1D)</li> <li>~AkimaSpline2D (cip::AkimaSpline2D)</li> <li>~CubicCellND (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>~CubicInterpND (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;)</li> <li>~Indexer (cip::Indexer)</li> <li>~LinearCellND (cip::LinearCellND&lt; T, 1 &gt;)</li> <li>~LinearInterp1D (cip::LinearInterp1D)</li> <li>~LinearInterp2D (cip::LinearInterp2D)</li> <li>~LinearInterp3D (cip::LinearInterp3D)</li> <li>~LinearInterp4D (cip::LinearInterp4D)</li> <li>~LinearInterpND (cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>~MonotonicSpline1D (cip::MonotonicSpline1D)</li> <li>~MonotonicSpline2D (cip::MonotonicSpline2D)</li> <li>~NaturalSpline1D (cip::NaturalSpline1D)</li> <li>~NaturalSpline2D (cip::NaturalSpline2D)</li> <li>~NaturalSpline3D (cip::NaturalSpline3D)</li> </ul>"},{"location":"reference/class_member_functions/","title":"Class Member Functions","text":""},{"location":"reference/class_member_functions/#a","title":"a","text":"<ul> <li>AkimaSpline1D (cip::AkimaSpline1D)</li> <li>AkimaSpline2D (cip::AkimaSpline2D)</li> <li>apply (cip::VectorN::Flatten, cip::VectorN::Flatten&lt; NestedVector, 1 &gt;)</li> </ul>"},{"location":"reference/class_member_functions/#b","title":"b","text":"<ul> <li>build (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>build_cell (cip::CubicInterpND, cip::LinearInterpND)</li> </ul>"},{"location":"reference/class_member_functions/#c","title":"c","text":"<ul> <li>calc_slopes (cip::AkimaSpline1D, cip::AkimaSpline2D, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::MonotonicSpline1D, cip::MonotonicSpline2D, cip::NaturalSpline1D, cip::NaturalSpline2D, cip::NaturalSpline3D)</li> <li>CubicCellND (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>calc_coeffs (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>calc_delta (cip::CubicCellND)</li> <li>calc_delta_ij (cip::CubicCellND)</li> <li>calc_h (cip::CubicCellND)</li> <li>calc_h3 (cip::CubicCellND)</li> <li>CubicInterpND (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;)</li> <li>cell_index (cip::Indexer)</li> <li>compute_c_J (cip::LinearCellND)</li> <li>compute_coefficients (cip::LinearCellND)</li> <li>compute_corner (cip::LinearCellND)</li> <li>calculate_total_size (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_functions/#d","title":"d","text":"<ul> <li>data (cip::VectorN)</li> <li>determine_dimensions (cip::VectorN)</li> <li>dimensions (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_functions/#e","title":"e","text":"<ul> <li>eval (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearCellND, cip::LinearCellND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>eval_poly (cip::CubicCellND)</li> <li>evaln (cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>emplace_back (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_functions/#g","title":"g","text":"<ul> <li>gamma (cip::LinearCellND)</li> <li>gather_corners (cip::LinearCellND)</li> <li>get_mdspan (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_functions/#i","title":"i","text":"<ul> <li>Indexer (cip::Indexer)</li> </ul>"},{"location":"reference/class_member_functions/#l","title":"l","text":"<ul> <li>LinearCellND (cip::LinearCellND, cip::LinearCellND&lt; T, 1 &gt;)</li> <li>LinearInterp1D (cip::LinearInterp1D)</li> <li>LinearInterp2D (cip::LinearInterp2D)</li> <li>LinearInterp3D (cip::LinearInterp3D)</li> <li>LinearInterp4D (cip::LinearInterp4D)</li> <li>LinearInterpND (cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_member_functions/#m","title":"m","text":"<ul> <li>MonotonicSpline1D (cip::MonotonicSpline1D)</li> <li>MonotonicSpline2D (cip::MonotonicSpline2D)</li> <li>move_into_submdspan (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_functions/#n","title":"n","text":"<ul> <li>NaturalSpline1D (cip::NaturalSpline1D)</li> <li>NaturalSpline2D (cip::NaturalSpline2D)</li> <li>NaturalSpline3D (cip::NaturalSpline3D)</li> </ul>"},{"location":"reference/class_member_functions/#o","title":"o","text":"<ul> <li>operator() (cip::VectorN, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;)</li> </ul>"},{"location":"reference/class_member_functions/#p","title":"p","text":"<ul> <li>populate_F (cip::CubicInterpND)</li> </ul>"},{"location":"reference/class_member_functions/#s","title":"s","text":"<ul> <li>sort_index (cip::Indexer)</li> <li>submdspan (cip::VectorN)</li> <li>submdspan_1d (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_functions/#v","title":"v","text":"<ul> <li>VectorN (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_functions/#_1","title":"~","text":"<ul> <li>~AkimaSpline1D (cip::AkimaSpline1D)</li> <li>~AkimaSpline2D (cip::AkimaSpline2D)</li> <li>~CubicCellND (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>~CubicInterpND (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;)</li> <li>~Indexer (cip::Indexer)</li> <li>~LinearCellND (cip::LinearCellND&lt; T, 1 &gt;)</li> <li>~LinearInterp1D (cip::LinearInterp1D)</li> <li>~LinearInterp2D (cip::LinearInterp2D)</li> <li>~LinearInterp3D (cip::LinearInterp3D)</li> <li>~LinearInterp4D (cip::LinearInterp4D)</li> <li>~LinearInterpND (cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>~MonotonicSpline1D (cip::MonotonicSpline1D)</li> <li>~MonotonicSpline2D (cip::MonotonicSpline2D)</li> <li>~NaturalSpline1D (cip::NaturalSpline1D)</li> <li>~NaturalSpline2D (cip::NaturalSpline2D)</li> <li>~NaturalSpline3D (cip::NaturalSpline3D)</li> </ul>"},{"location":"reference/class_member_variables/","title":"Class Member Variables","text":""},{"location":"reference/class_member_variables/#a","title":"a","text":"<ul> <li>a0 (cip::LinearCellND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_member_variables/#b","title":"b","text":"<ul> <li>b0 (cip::LinearCellND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_member_variables/#c","title":"c","text":"<ul> <li>coeffs (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> <li>cells (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>c (cip::LinearCellND)</li> </ul>"},{"location":"reference/class_member_variables/#d","title":"d","text":"<ul> <li>data_ (cip::VectorN)</li> <li>dimensions_ (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_variables/#f","title":"f","text":"<ul> <li>F (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;)</li> <li>f (cip::LinearCellND, cip::LinearInterpND)</li> </ul>"},{"location":"reference/class_member_variables/#h","title":"h","text":"<ul> <li>H (cip::LinearCellND)</li> </ul>"},{"location":"reference/class_member_variables/#i","title":"i","text":"<ul> <li>indexers (cip::CubicInterpND, cip::LinearInterpND)</li> <li>indexer (cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>index_back (cip::Indexer)</li> <li>index_front (cip::Indexer)</li> </ul>"},{"location":"reference/class_member_variables/#m","title":"m","text":"<ul> <li>mdspan (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_variables/#n","title":"n","text":"<ul> <li>numCoeffs (cip::CubicCellND)</li> <li>numCorners (cip::CubicCellND, cip::LinearCellND)</li> </ul>"},{"location":"reference/class_member_variables/#o","title":"o","text":"<ul> <li>order (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_member_variables/#s","title":"s","text":"<ul> <li>size_t_two (cip::CubicInterpND)</li> </ul>"},{"location":"reference/class_member_variables/#x","title":"x","text":"<ul> <li>x (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::Indexer, cip::LinearCellND)</li> <li>xi (cip::CubicInterpND, cip::LinearInterpND)</li> <li>x_back (cip::Indexer)</li> <li>x_delta (cip::Indexer)</li> <li>x_front (cip::Indexer)</li> <li>x0 (cip::LinearCellND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_member_variables/#y","title":"y","text":"<ul> <li>y (cip::CubicInterpND)</li> </ul>"},{"location":"reference/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"reference/class_member_typedefs/#a","title":"a","text":"<ul> <li>Array (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::LinearInterpND)</li> <li>Array2 (cip::CubicCellND)</li> <li>ArrayN (cip::CubicCellND)</li> <li>Alpha (cip::CubicCellND&lt; T, 1 &gt;)</li> </ul>"},{"location":"reference/class_member_typedefs/#c","title":"c","text":"<ul> <li>CoeffsArray (cip::CubicCellND)</li> <li>Cell (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>Cells (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND)</li> </ul>"},{"location":"reference/class_member_typedefs/#d","title":"d","text":"<ul> <li>Delta (cip::CubicCellND)</li> </ul>"},{"location":"reference/class_member_typedefs/#f","title":"f","text":"<ul> <li>Ff (cip::CubicInterpND)</li> <li>Ff2 (cip::CubicInterpND)</li> <li>F (cip::LinearInterpND)</li> </ul>"},{"location":"reference/class_member_typedefs/#i","title":"i","text":"<ul> <li>Indexers (cip::CubicInterpND, cip::LinearInterpND)</li> <li>IndexArray (cip::VectorN)</li> </ul>"},{"location":"reference/class_member_typedefs/#m","title":"m","text":"<ul> <li>Mdspan1D (cip::AkimaSpline2D, cip::CubicInterpND, cip::MonotonicSpline2D, cip::NaturalSpline2D, cip::NaturalSpline3D, cip::VectorN)</li> <li>Mdspan (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::LinearCellND, cip::VectorN)</li> </ul>"},{"location":"reference/class_member_typedefs/#n","title":"n","text":"<ul> <li>NomArray (cip::LinearCellND)</li> </ul>"},{"location":"reference/class_member_typedefs/#p","title":"p","text":"<ul> <li>Pr (cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearInterpND)</li> </ul>"},{"location":"reference/class_member_typedefs/#s","title":"s","text":"<ul> <li>Span (cip::CubicCellND, cip::CubicCellND&lt; T, 1 &gt;, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::LinearCellND, cip::LinearCellND&lt; T, 1 &gt;, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;)</li> <li>Spans (cip::CubicCellND, cip::LinearCellND)</li> </ul>"},{"location":"reference/class_member_typedefs/#v","title":"v","text":"<ul> <li>Vector (cip::AkimaSpline1D, cip::AkimaSpline2D, cip::CubicInterpND, cip::CubicInterpND&lt; T, 1 &gt;, cip::Indexer, cip::LinearInterp1D, cip::LinearInterp2D, cip::LinearInterp3D, cip::LinearInterp4D, cip::LinearInterpND, cip::LinearInterpND&lt; T, 1 &gt;, cip::MonotonicSpline1D, cip::MonotonicSpline2D, cip::NaturalSpline1D, cip::NaturalSpline2D, cip::NaturalSpline3D, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Clamped, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::Natural, T, Tx, Tf &gt;, cip::setNaturalSplineBoundaryCondition&lt; BoundaryConditionType::NotAKnot, T, Tx, Tf &gt;)</li> <li>VectorN (cip::AkimaSpline2D, cip::MonotonicSpline2D, cip::NaturalSpline2D, cip::NaturalSpline3D)</li> <li>VectorN2 (cip::CubicInterpND&lt; T, 1 &gt;)</li> <li>Vector2 (cip::LinearInterp1D, cip::LinearInterp2D)</li> <li>Vector3 (cip::LinearInterp3D)</li> <li>Vector4 (cip::LinearInterp4D)</li> </ul>"},{"location":"reference/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"reference/namespace_members/","title":"Namespace Members","text":""},{"location":"reference/namespace_members/#a","title":"a","text":"<ul> <li>akima_slopes (cip)</li> </ul>"},{"location":"reference/namespace_members/#b","title":"b","text":"<ul> <li>BoundaryConditionType (cip)</li> <li>binomial (cip)</li> <li>binomial_power_coefficient (cip)</li> <li>build_coordinate_indices (cip)</li> <li>build_coordinate_indices_impl (cip)</li> </ul>"},{"location":"reference/namespace_members/#c","title":"c","text":"<ul> <li>call_move_into_submdspan (cip)</li> <li>call_submdspan_1d (cip)</li> <li>compute_mixed_derivatives (cip)</li> <li>compute_mixed_derivatives_impl (cip)</li> </ul>"},{"location":"reference/namespace_members/#f","title":"f","text":"<ul> <li>factorial (cip)</li> <li>for_each_dimension (cip)</li> <li>for_each_dimension_impl (cip)</li> </ul>"},{"location":"reference/namespace_members/#i","title":"i","text":"<ul> <li>iterate_over_indices (cip)</li> </ul>"},{"location":"reference/namespace_members/#m","title":"m","text":"<ul> <li>make_zero_tuple (cip)</li> <li>monotonic_slopes (cip)</li> </ul>"},{"location":"reference/namespace_members/#n","title":"n","text":"<ul> <li>natural_spline_slopes (cip)</li> </ul>"},{"location":"reference/namespace_members/#p","title":"p","text":"<ul> <li>power (cip)</li> </ul>"},{"location":"reference/namespace_members/#s","title":"s","text":"<ul> <li>SIZE_T_ZERO (cip)</li> </ul>"},{"location":"reference/namespace_members/#t","title":"t","text":"<ul> <li>thomas_algorithm (cip)</li> </ul>"},{"location":"reference/namespace_members/#u","title":"u","text":"<ul> <li>update_tuple_element (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"reference/namespace_member_functions/#a","title":"a","text":"<ul> <li>akima_slopes (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#b","title":"b","text":"<ul> <li>binomial (cip)</li> <li>binomial_power_coefficient (cip)</li> <li>build_coordinate_indices (cip)</li> <li>build_coordinate_indices_impl (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#c","title":"c","text":"<ul> <li>call_move_into_submdspan (cip)</li> <li>call_submdspan_1d (cip)</li> <li>compute_mixed_derivatives (cip)</li> <li>compute_mixed_derivatives_impl (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#f","title":"f","text":"<ul> <li>factorial (cip)</li> <li>for_each_dimension (cip)</li> <li>for_each_dimension_impl (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#i","title":"i","text":"<ul> <li>iterate_over_indices (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#m","title":"m","text":"<ul> <li>make_zero_tuple (cip)</li> <li>monotonic_slopes (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#n","title":"n","text":"<ul> <li>natural_spline_slopes (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#p","title":"p","text":"<ul> <li>power (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#t","title":"t","text":"<ul> <li>thomas_algorithm (cip)</li> </ul>"},{"location":"reference/namespace_member_functions/#u","title":"u","text":"<ul> <li>update_tuple_element (cip)</li> </ul>"},{"location":"reference/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"reference/namespace_member_variables/#s","title":"s","text":"<ul> <li>SIZE_T_ZERO (cip)</li> </ul>"},{"location":"reference/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"reference/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"reference/namespace_member_enums/#b","title":"b","text":"<ul> <li>BoundaryConditionType (cip)</li> </ul>"},{"location":"reference/functions/","title":"Functions","text":""},{"location":"reference/functions/#p","title":"p","text":"<ul> <li>PYBIND11_MODULE (cubinterpp_py_module.cpp)</li> </ul>"},{"location":"reference/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"reference/variables/","title":"Variables","text":""},{"location":"reference/variables/#d","title":"d","text":"<ul> <li>DoubleVector (cubinterpp_py_module.cpp)</li> <li>DoubleVector2 (cubinterpp_py_module.cpp)</li> <li>DoubleVector3 (cubinterpp_py_module.cpp)</li> </ul>"},{"location":"reference/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}